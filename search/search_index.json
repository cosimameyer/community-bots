{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome \ud83d\udc4b","text":""},{"location":"#what-this-project-is-about","title":"What This Project is About","text":"<p>This project focuses on building community-driven bots for Bluesky and Mastodon to support and grow the Python, R, and data community. The bots help by </p> <ul> <li>Boosting posts tagged with #pyladies or #rladies, </li> <li>Posting useful resources by PyLadies and R-Ladies,  </li> <li>Sharing portraits of amazing women in tech, and</li> <li>Celebrating community achievements. </li> </ul> <p>With these bots, I hope to give others an automated megaphone to increase visibility for underrepresented groups in the tech space.</p> <p></p> <p>Designed to increase engagement and visibility, the bots run automatically open-source tools. The project also provides a detailed, open guide for others interested in setting up similar bots. At its core, it\u2019s about using automation to strengthen and connect our communities.</p> <p>This projects marries multiple components:</p> <ul> <li>Sharing content by PyLadies and R-Ladies</li> <li>Sharing Amazing Women in Tech</li> </ul> <p>Here is more about the project:</p>"},{"location":"#blog-posts","title":"Blog Posts","text":"<ul> <li> <p>Building Mastodon Bots </p> </li> <li> <p>How to add Gemini to your Python project</p> <p></p> </li> <li> <p>Awesome PyLadies' Repository </p> </li> </ul>"},{"location":"#talks","title":"Talks","text":"<ul> <li>Code &amp; Community @ PyConDE/PyData 2025 </li> <li>Sparkling Connection @ PyLadiesCon 2023 </li> </ul>"},{"location":"#where-can-i-find-the-bots","title":"Where can I find the bots?","text":"<p>You can find the bots on Bluesky (and formerly also on Mastodon). I'd love to extend it to other platforms - so if you have ideas, let me know!</p>"},{"location":"#bluesky","title":"Bluesky","text":"<ul> <li> <p>PyLadies Bot</p> <p>  Hop over to Bluesky and meet the bot</p> </li> <li> <p>R-Ladies Bot</p> <p>  Hop over to Bluesky and meet the bot</p> </li> </ul>"},{"location":"#mastodon","title":"Mastodon","text":"<p>\ud83d\udc4b Those bots are currently looking for a new home (i.e., an instance at Mastodon). If you know of something, please feel free to reach out!</p>"},{"location":"contribute/","title":"How to contribute to the project","text":"<p>Contributions are highly welcomed! </p> I have PyLadies/R-Ladies content (blog, YouTube channel, ...), how do I contribute it to the bot? <ul> <li>Awesome PyLadies' Repository</li> <li>Awesome R-Ladies' Repository</li> </ul> I have an idea how to improve the code - how can I share it? <p>Amazing, I'm so happy that you took your time to go through the code and want to make it better!</p> <ul> <li>If you have an idea (but no solution yet), feel free to open an issue or reach out to Cosima.</li> <li>If you have an idea and a solution - amazing! Let's work together with PRs \ud83d\ude0a</li> </ul> How to collaborate on a code level? <p>To  allow dependency management, this repository uses <code>pdm</code> and <code>pre-commit</code> hooks. To get started, there's not a lot you have to do. Just follow these steps:</p> <ol> <li>Install <code>pdm</code>. Here are options how to do it.</li> <li>Now you're good to go. <code>pyproject.toml</code> contains all relevant info. You just need to run <code>pdm install</code> in you terminal. This will create a <code>.venv/</code> folder with the Python packages installed in.</li> <li>If you want to add a package, don't do it manually. Run <code>pdm add &lt;package_name&gt;</code>.</li> <li>This repository also relies on pre-commit hooks. To have them activated on your end, make sure to run <code>pdm run pre-commit install</code>. They'll be running in the background and just complain if something's not right. Otherwise, you'll not really see them \ud83d\ude0a</li> </ol> <p>In case you run into issues here, let me know! We'll figure it out \ud83d\ude0a</p> What's the default branch? <p>The default branch is main. To contribute to it, create a feature branch and open a PR with your changes. Direct pushes to <code>main</code> are blocked (because that's where our production code is) but collaboration is of course highly welcome \ud83d\ude0a</p> Any other open questions? <p>If you have any questions or suggestions, please reach out to Cosima or open an issue.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#src.boost_mentions","title":"<code>boost_mentions</code>","text":"<p>Module to boost mentions that tag the community bots</p>"},{"location":"reference/#src.boost_mentions.BoostMentions","title":"<code>BoostMentions</code>","text":"<p>Class to handle boosting mentions of the community bots.</p> Source code in <code>src/boost_mentions.py</code> <pre><code>class BoostMentions():\n    \"\"\"\n    Class to handle boosting mentions of the community bots.\n    \"\"\"\n    def __init__(self, config_dict=None, no_dry_run=True):\n        self.logger = logging.getLogger(__name__)\n        logging.basicConfig(level=logging.INFO)\n\n        self.process_images = False\n        self.no_dry_run = no_dry_run\n        self.config_dict = config_dict\n\n    def boost_mentions(self):\n        \"\"\"\n        Method to boost mentions on social media platforms.\n        \"\"\"\n        self.set_up_config_dict()\n\n        self.logger.info(\"==========================\")\n        client_name = self.config_dict.get(\"client_name\")\n        self.logger.info('Initializing %s Bot', client_name)\n        self.logger.info(\"=================%s\", \"=\" * len(client_name or \"\"))\n        self.logger.info(' &gt; Connecting to %s',\n                         self.config_dict['api_base_url'])\n\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            account, client = login_mastodon(self.config_dict)\n            notifications = client.notifications(types=['mention'])\n            self.logger.info(' &gt; Fetched account data for %s',\n                             account.acct)\n\n            self.logger.info(\n                ' &gt; Beginning search-loop and toot and boost toots'\n            )\n            self.logger.info('------------------------')\n\n            self.logger.info(\" &gt; Reading statuses to identify tootable status\")\n            for notification in notifications:\n                if not notification.status.favourited and \\\n                        notification.status.account.acct != account.acct:\n                    # Boost and favorite the new status\n                    try:\n                        self.logger.info(\n                            \"   * Boosting new toot by %s viewable at: %s\",\n                            notification.account.username,\n                            notification.status.url,\n                        )\n                        client.status_reblog(notification.status.id)\n                        client.status_favourite(notification.status.id)\n                    except Exception as e:\n                        self.logger.info(\n                            \"   * Boosting new toot by %s did not work: %s \",\n                            notification.account.username,\n                            e,\n                        )\n        elif self.config_dict[\"platform\"] == \"bluesky\":\n            client = login_bluesky(self.config_dict)\n            self.logger.info(\" &gt; Fetched account data\")\n\n            self.logger.info(\" &gt; Beginning search-loop and repost posts\")\n            self.logger.info(\"------------------------\")\n\n            self.logger.info(\n                \" &gt; Reading statuses to identify postable statuses\"\n            )\n            last_seen_at = client.get_current_time_iso()\n            response = client.app.bsky.notification.list_notifications()\n            timeline = client.get_timeline(algorithm='reverse-chronological')\n            cids = [post.post.cid for post in timeline.feed]\n\n            for notification in response.notifications:\n                if (\n                    notification.reason == \"mention\"\n                    and notification.cid not in cids\n                ):\n                    try:\n                        self.logger.info(\n                            \"   * Reposted post reference: %s\",\n                            client.repost(\n                                uri=notification.uri,\n                                cid=notification.cid\n                            )\n                        )\n                    except Exception as e:\n                        self.logger.info(\n                            \"\"\"\n                            * Reposting new post with URI %s\n                            and CID %s did not work because of %s -\n                            going to the next post.\n                            \"\"\",\n                            notification.uri,\n                            notification.cid,\n                            e,\n                        )\n\n            client.app.bsky.notification.update_seen({'seen_at': last_seen_at})\n            self.logger.info(\n                'Successfully process notification. Last seen at: %s',\n                last_seen_at\n            )\n\n    def set_up_config_dict(self):\n        \"\"\"\n        Method to set up the config dictionary with the required parameters\n        \"\"\"\n        self.config_dict = {\n            \"platform\": os.getenv(\"PLATFORM\"),\n            \"password\": os.getenv(\"PASSWORD\"),\n            \"username\": os.getenv(\"USERNAME\"),\n            \"client_name\": os.getenv(\"CLIENT_NAME\")\n        }\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            self.config_dict[\"mastodon_visiblity\"] = config.MASTODON_VISIBILITY\n            self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n            self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n            self.config_dict[\"client_cred_file\"] = os.getenv(\n                'BOT_CLIENTCRED_SECRET'\n            )\n            self.config_dict[\"timeline_depth_limit\"] = 40\n        else:\n            self.config_dict[\"api_base_url\"] = \"bluesky\"\n</code></pre>"},{"location":"reference/#src.boost_mentions.BoostMentions.boost_mentions","title":"<code>boost_mentions()</code>","text":"<p>Method to boost mentions on social media platforms.</p> Source code in <code>src/boost_mentions.py</code> <pre><code>def boost_mentions(self):\n    \"\"\"\n    Method to boost mentions on social media platforms.\n    \"\"\"\n    self.set_up_config_dict()\n\n    self.logger.info(\"==========================\")\n    client_name = self.config_dict.get(\"client_name\")\n    self.logger.info('Initializing %s Bot', client_name)\n    self.logger.info(\"=================%s\", \"=\" * len(client_name or \"\"))\n    self.logger.info(' &gt; Connecting to %s',\n                     self.config_dict['api_base_url'])\n\n    if self.config_dict[\"platform\"] == \"mastodon\":\n        account, client = login_mastodon(self.config_dict)\n        notifications = client.notifications(types=['mention'])\n        self.logger.info(' &gt; Fetched account data for %s',\n                         account.acct)\n\n        self.logger.info(\n            ' &gt; Beginning search-loop and toot and boost toots'\n        )\n        self.logger.info('------------------------')\n\n        self.logger.info(\" &gt; Reading statuses to identify tootable status\")\n        for notification in notifications:\n            if not notification.status.favourited and \\\n                    notification.status.account.acct != account.acct:\n                # Boost and favorite the new status\n                try:\n                    self.logger.info(\n                        \"   * Boosting new toot by %s viewable at: %s\",\n                        notification.account.username,\n                        notification.status.url,\n                    )\n                    client.status_reblog(notification.status.id)\n                    client.status_favourite(notification.status.id)\n                except Exception as e:\n                    self.logger.info(\n                        \"   * Boosting new toot by %s did not work: %s \",\n                        notification.account.username,\n                        e,\n                    )\n    elif self.config_dict[\"platform\"] == \"bluesky\":\n        client = login_bluesky(self.config_dict)\n        self.logger.info(\" &gt; Fetched account data\")\n\n        self.logger.info(\" &gt; Beginning search-loop and repost posts\")\n        self.logger.info(\"------------------------\")\n\n        self.logger.info(\n            \" &gt; Reading statuses to identify postable statuses\"\n        )\n        last_seen_at = client.get_current_time_iso()\n        response = client.app.bsky.notification.list_notifications()\n        timeline = client.get_timeline(algorithm='reverse-chronological')\n        cids = [post.post.cid for post in timeline.feed]\n\n        for notification in response.notifications:\n            if (\n                notification.reason == \"mention\"\n                and notification.cid not in cids\n            ):\n                try:\n                    self.logger.info(\n                        \"   * Reposted post reference: %s\",\n                        client.repost(\n                            uri=notification.uri,\n                            cid=notification.cid\n                        )\n                    )\n                except Exception as e:\n                    self.logger.info(\n                        \"\"\"\n                        * Reposting new post with URI %s\n                        and CID %s did not work because of %s -\n                        going to the next post.\n                        \"\"\",\n                        notification.uri,\n                        notification.cid,\n                        e,\n                    )\n\n        client.app.bsky.notification.update_seen({'seen_at': last_seen_at})\n        self.logger.info(\n            'Successfully process notification. Last seen at: %s',\n            last_seen_at\n        )\n</code></pre>"},{"location":"reference/#src.boost_mentions.BoostMentions.set_up_config_dict","title":"<code>set_up_config_dict()</code>","text":"<p>Method to set up the config dictionary with the required parameters</p> Source code in <code>src/boost_mentions.py</code> <pre><code>def set_up_config_dict(self):\n    \"\"\"\n    Method to set up the config dictionary with the required parameters\n    \"\"\"\n    self.config_dict = {\n        \"platform\": os.getenv(\"PLATFORM\"),\n        \"password\": os.getenv(\"PASSWORD\"),\n        \"username\": os.getenv(\"USERNAME\"),\n        \"client_name\": os.getenv(\"CLIENT_NAME\")\n    }\n    if self.config_dict[\"platform\"] == \"mastodon\":\n        self.config_dict[\"mastodon_visiblity\"] = config.MASTODON_VISIBILITY\n        self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n        self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n        self.config_dict[\"client_cred_file\"] = os.getenv(\n            'BOT_CLIENTCRED_SECRET'\n        )\n        self.config_dict[\"timeline_depth_limit\"] = 40\n    else:\n        self.config_dict[\"api_base_url\"] = \"bluesky\"\n</code></pre>"},{"location":"reference/#src.boost_tags","title":"<code>boost_tags</code>","text":"<p>Module to boost posts containing specific tags using community bots.</p>"},{"location":"reference/#src.boost_tags.BoostTags","title":"<code>BoostTags</code>","text":"<p>Handles boosting of posts containing specified tags across different platforms. Currently supports Bluesky. Mastodon support is stubbed.</p> Source code in <code>src/boost_tags.py</code> <pre><code>class BoostTags:\n    \"\"\"\n    Handles boosting of posts containing specified tags across different platforms.\n    Currently supports Bluesky. Mastodon support is stubbed.\n    \"\"\"\n\n    def __init__(self, config_dict: dict | None = None, no_dry_run: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the BoostTags handler.\n\n        Args:\n            config_dict (dict | None): Configuration dictionary for the bot.\n                If None, values will be loaded from environment variables.\n            no_dry_run (bool): If True, actually perform reposts instead of dry-run.\n        \"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.logger.setLevel(logging.INFO)\n\n        self.config_dict = config_dict\n        self.no_dry_run = no_dry_run\n\n    def repost_tags_mastodon(self, client) -&gt; None:\n        \"\"\"\n        Repost Mastodon statuses containing the configured tags.\n\n        Args:\n            client: Authenticated Mastodon client instance.\n\n        Notes:\n            Currently non-functional since account fetching is commented out.\n        \"\"\"\n        if \"tags\" not in self.config_dict:\n            self.logger.warning(\"No tags configured for Mastodon reposts.\")\n            return\n\n        for tag in self.config_dict[\"tags\"]:\n            tag = tag.lower().strip(\"# \")\n            self.logger.info(\"Reading timeline for new toots tagged #%s\", tag)\n\n            try:\n                statuses = client.timeline_hashtag(\n                    tag,\n                    limit=self.config_dict.get(\"timeline_depth_limit\", 40),\n                )\n            except (\n                MastodonNetworkError,\n                MastodonAPIError,\n                ConnectionError,\n                TimeoutError\n            ) as e:\n                # NOTE: Replace/extend with library-specific \n                # exceptions as needed.\n                self.logger.error(\n                    \"Network/API error when fetching statuses: %s. Retrying...\",\n                    e\n                )\n                time.sleep(30)\n                continue\n\n            time.sleep(0.1)  # rate limiting\n\n            for status in statuses:\n                domain = urlparse(status.url).netloc\n                if (\n                    not getattr(status, \"favourited\", False)\n                    and domain not in config.IGNORE_SERVERS\n                    and getattr(status.account, \"acct\", None) != self.config_dict.get(\"username\")\n                ):\n                    self.logger.info(\n                        \"Boosting toot by %s tagged #%s (%s)\",\n                        status.account.username,\n                        tag,\n                        status.url,\n                    )\n                    client.status_reblog(status.id)\n                    client.status_favourite(status.id)\n\n    def boost_tags(self) -&gt; None:\n        \"\"\"\n        Main entrypoint to start boosting tags based on configuration.\n\n        Loads configuration from environment variables if not provided.\n        Handles platform-specific reposting logic.\n        \"\"\"\n        if self.config_dict is None and self.no_dry_run:\n            self._load_config_from_env()\n\n        platform = self.config_dict.get(\"platform\")\n        client_name = self.config_dict.get(\"client_name\", \"Unknown\")\n        self.logger.info(\"========\")\n        self.logger.info(\"Initializing %s Bot\", client_name)\n        self.logger.info(\"=\" * (20 + len(client_name)))\n        self.logger.info(\"Connecting to %s\", self.config_dict[\"api_base_url\"])\n\n        if platform == \"mastodon\":\n            self._boost_tags_mastodon()\n            self.logger.warning(\"Mastodon support is currently not implemented.\")\n        elif platform == \"bluesky\":\n            self._boost_tags_bluesky()\n        else:\n            self.logger.error(\"Unsupported platform: %s\", platform)\n\n    def _load_config_from_env(self) -&gt; None:\n        \"\"\"Load configuration values from environment variables into self.config_dict.\"\"\"\n        self.config_dict = {\n            \"platform\": os.getenv(\"PLATFORM\", \"\").lower(),\n            \"password\": os.getenv(\"PASSWORD\"),\n            \"username\": os.getenv(\"USERNAME\"),\n            \"client_name\": os.getenv(\"CLIENT_NAME\", \"CommunityBot\"),\n            \"tags\": os.getenv(\"TAGS_TO_BOOST\", \"\").split(\",\"),\n        }\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            self.config_dict.update({\n                \"mastodon_visibility\": config.MASTODON_VISIBILITY,\n                \"api_base_url\": config.API_BASE_URL,\n                \"access_token\": os.getenv(\"ACCESS_TOKEN\"),\n                \"client_cred_file\": os.getenv(\"BOT_CLIENTCRED_SECRET\"),\n                \"timeline_depth_limit\": 40,\n            })\n        else:\n            self.config_dict[\"api_base_url\"] = \"bluesky\"\n\n    def _boost_tags_mastodon(self) -&gt; None:\n        \"\"\"Handle reposting tags on Mastodon.\"\"\"\n        # # Commented because it wasn't fully working\n\n        # account, client = login_mastodon(config_dict)\n        # self.logger.info(f\" &gt; Fetched account data for {account.acct}\")\n\n        # repost_tags_mastodon(client, config_dict)\n        self.logger.info(\n            \"\"\"\n            This feature currently doesn't work for Mastodon.\n            It's deployed using AWS.\n            \"\"\"\n        )\n\n    def _boost_tags_bluesky(self) -&gt; None:\n        \"\"\"Handle reposting tags on Bluesky.\"\"\"\n        if not self.no_dry_run:\n            self.logger.info(\"Dry-run mode: no reposts will be made.\")\n            return\n\n        client = login_bluesky(self.config_dict)\n        self.logger.info(\"Fetched Bluesky account data.\")\n        self.logger.info(\"Starting search-loop for reposting.\")\n\n        timeline = client.get_timeline(algorithm=\"reverse-chronological\")\n        seen_cids = {post.post.cid for post in timeline.feed}\n\n        for tag in self.config_dict[\"tags\"]:\n            response = client.app.bsky.feed.search_posts(\n                params={\"q\": tag, \"tag\": [tag], \"sort\": \"top\", \"limit\": 50}\n            )\n            for post in response.posts:\n                tags_in_post = {\n                    t.strip(\"#\").lower()\n                    for t in post.record.text.split()\n                    if t.startswith(\"#\")\n                }\n\n                if tag.lower() in tags_in_post and post.cid not in seen_cids:\n                    try:\n                        result = client.repost(uri=post.uri, cid=post.cid)\n                        self.logger.info(\n                            \"Reposted post by %s (ref: %s)\",\n                            post.author.handle, result\n                        )\n                    except AtProtocolError as e:\n                        self.logger.error(\n                            \"Failed to repost URI %s, CID %s: %s\",\n                            post.uri,\n                            post.cid,\n                            e,\n                        )\n                    time.sleep(0.1)  # avoid hammering API\n\n        self.logger.info(\"Finished processing Bluesky reposts.\")\n</code></pre>"},{"location":"reference/#src.boost_tags.BoostTags.__init__","title":"<code>__init__(config_dict=None, no_dry_run=True)</code>","text":"<p>Initialize the BoostTags handler.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>dict | None</code> <p>Configuration dictionary for the bot. If None, values will be loaded from environment variables.</p> <code>None</code> <code>no_dry_run</code> <code>bool</code> <p>If True, actually perform reposts instead of dry-run.</p> <code>True</code> Source code in <code>src/boost_tags.py</code> <pre><code>def __init__(self, config_dict: dict | None = None, no_dry_run: bool = True) -&gt; None:\n    \"\"\"\n    Initialize the BoostTags handler.\n\n    Args:\n        config_dict (dict | None): Configuration dictionary for the bot.\n            If None, values will be loaded from environment variables.\n        no_dry_run (bool): If True, actually perform reposts instead of dry-run.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.logger.setLevel(logging.INFO)\n\n    self.config_dict = config_dict\n    self.no_dry_run = no_dry_run\n</code></pre>"},{"location":"reference/#src.boost_tags.BoostTags.boost_tags","title":"<code>boost_tags()</code>","text":"<p>Main entrypoint to start boosting tags based on configuration.</p> <p>Loads configuration from environment variables if not provided. Handles platform-specific reposting logic.</p> Source code in <code>src/boost_tags.py</code> <pre><code>def boost_tags(self) -&gt; None:\n    \"\"\"\n    Main entrypoint to start boosting tags based on configuration.\n\n    Loads configuration from environment variables if not provided.\n    Handles platform-specific reposting logic.\n    \"\"\"\n    if self.config_dict is None and self.no_dry_run:\n        self._load_config_from_env()\n\n    platform = self.config_dict.get(\"platform\")\n    client_name = self.config_dict.get(\"client_name\", \"Unknown\")\n    self.logger.info(\"========\")\n    self.logger.info(\"Initializing %s Bot\", client_name)\n    self.logger.info(\"=\" * (20 + len(client_name)))\n    self.logger.info(\"Connecting to %s\", self.config_dict[\"api_base_url\"])\n\n    if platform == \"mastodon\":\n        self._boost_tags_mastodon()\n        self.logger.warning(\"Mastodon support is currently not implemented.\")\n    elif platform == \"bluesky\":\n        self._boost_tags_bluesky()\n    else:\n        self.logger.error(\"Unsupported platform: %s\", platform)\n</code></pre>"},{"location":"reference/#src.boost_tags.BoostTags.repost_tags_mastodon","title":"<code>repost_tags_mastodon(client)</code>","text":"<p>Repost Mastodon statuses containing the configured tags.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Authenticated Mastodon client instance.</p> required Notes <p>Currently non-functional since account fetching is commented out.</p> Source code in <code>src/boost_tags.py</code> <pre><code>def repost_tags_mastodon(self, client) -&gt; None:\n    \"\"\"\n    Repost Mastodon statuses containing the configured tags.\n\n    Args:\n        client: Authenticated Mastodon client instance.\n\n    Notes:\n        Currently non-functional since account fetching is commented out.\n    \"\"\"\n    if \"tags\" not in self.config_dict:\n        self.logger.warning(\"No tags configured for Mastodon reposts.\")\n        return\n\n    for tag in self.config_dict[\"tags\"]:\n        tag = tag.lower().strip(\"# \")\n        self.logger.info(\"Reading timeline for new toots tagged #%s\", tag)\n\n        try:\n            statuses = client.timeline_hashtag(\n                tag,\n                limit=self.config_dict.get(\"timeline_depth_limit\", 40),\n            )\n        except (\n            MastodonNetworkError,\n            MastodonAPIError,\n            ConnectionError,\n            TimeoutError\n        ) as e:\n            # NOTE: Replace/extend with library-specific \n            # exceptions as needed.\n            self.logger.error(\n                \"Network/API error when fetching statuses: %s. Retrying...\",\n                e\n            )\n            time.sleep(30)\n            continue\n\n        time.sleep(0.1)  # rate limiting\n\n        for status in statuses:\n            domain = urlparse(status.url).netloc\n            if (\n                not getattr(status, \"favourited\", False)\n                and domain not in config.IGNORE_SERVERS\n                and getattr(status.account, \"acct\", None) != self.config_dict.get(\"username\")\n            ):\n                self.logger.info(\n                    \"Boosting toot by %s tagged #%s (%s)\",\n                    status.account.username,\n                    tag,\n                    status.url,\n                )\n                client.status_reblog(status.id)\n                client.status_favourite(status.id)\n</code></pre>"},{"location":"reference/#src.config","title":"<code>config</code>","text":"<p>Config file for community bots</p>"},{"location":"reference/#src.debug","title":"<code>debug</code>","text":"<p>This script aims at making debugging easier</p>"},{"location":"reference/#src.debug.DebugBots","title":"<code>DebugBots</code>","text":"<p>Class to handle debugging of all modules.</p> Source code in <code>src/debug.py</code> <pre><code>class DebugBots:\n    \"\"\"\n    Class to handle debugging of all modules.\n    \"\"\"\n    def __init__(self):\n        self.bot = 'rladies'  # 'pyladies' or 'rladies'\n        self.what_to_debug = 'blog'  # 'blog' or 'boost_tags' or 'rss' or 'anniversary\n        self.platform = 'bluesky'  # 'bluesky' or 'mastodon'\n        self.no_dry_run = False\n\n    def start_debug(self):\n        \"\"\"Start debugging.\"\"\"\n        if self.what_to_debug == 'blog':\n            config_dict = self.get_config_blog()\n            promote_blog_post_handler = PromoteBlogPost(\n                config_dict,\n                self.no_dry_run\n            )\n            promote_blog_post_handler.promote_blog_post()\n\n        elif self.what_to_debug == 'rss':\n            config_dict = self.get_config_rss()\n            rss_data_handler = RSSData(\n                config_dict,\n                self.no_dry_run\n            )\n            rss_data_handler.get_rss_data()\n\n        elif self.what_to_debug == 'boost_tags':\n            config_dict = self.get_config_boost()\n            boost_tags_handler = BoostTags(\n                config_dict,\n                self.no_dry_run\n            )\n            boost_tags_handler.boost_tags()\n\n        elif self.what_to_debug == 'boost_mentions':\n            config_dict = self.get_config_boost()\n            boost_tags_handler = BoostMentions(\n                config_dict,\n                self.no_dry_run\n            )\n            boost_tags_handler.boost_mentions()\n\n        elif self.what_to_debug == 'anniversary':\n            config_dict = self.get_config_anniversary()\n            promote_anniversary_handler = PromoteAnniversary(\n                config_dict,\n                self.no_dry_run\n            )\n            promote_anniversary_handler.promote_anniversary()\n\n    def get_config_blog(self):\n        \"\"\"Method to generate config for promoting blog posts\"\"\"\n        if self.bot == 'pyladies':\n            if self.platform == 'bluesky':\n                return {\n                    \"archive\": \"pyladies_archive_directory_bluesky\",\n                    \"counter\": \"metadata/pyladies_counter_bluesky.txt\",\n                    \"json_file\": \"metadata/pyladies_meta_data.json\",\n                    \"client_name\": \"pyladies_self.bot\",\n                    \"images\": \"pyladies_images\",\n                    \"api_base_url\": self.platform,\n                    \"mastodon\": None,\n                    \"gen_ai_support\": True,\n                    \"gemini_model_name\": \"gemini-2.5-flash\",\n                    \"password\": os.getenv(\"PYLADIES_BSKY_PASSWORD\"),\n                    \"username\": os.getenv(\"PYLADIES_BSKY_USERNAME\"),\n                    \"platform\": self.platform,\n                }\n            return {\n                'archive': 'pyladies_archive_directory',\n                'counter': 'pyladies_counter.txt',\n                'json_file': 'metadata/pyladies_meta_data.json',\n                'client_name': 'pyladies_self.bot',\n                'mastodon': None,\n            }\n\n        if self.bot == 'rladies':\n            if self.platform == 'bluesky':\n                return {\n                    \"archive\": \"rladies_archive_directory_bluesky\",\n                    \"counter\": \"../metadata/rladies_counter_bluesky.txt\",\n                    \"json_file\": \"../metadata/rladies_meta_data.json\",\n                    \"client_name\": \"rladies_self.bot\",\n                    \"images\": \"rladies_images\",\n                    \"api_base_url\": self.platform,\n                    \"mastodon\": None,\n                    \"password\": os.getenv(\"RLADIES_BSKY_PASSWORD\"),\n                    \"username\": os.getenv(\"RLADIES_BSKY_USERNAME\"),\n                    \"platform\": self.platform,\n                }\n            return {\n                \"archive\": \"rladies_archive_directory\",\n                \"counter\": \"../metadata/rladies_counter.txt\",\n                \"json_file\": \"../metadata/rladies_meta_data.json\",\n                \"client_name\": \"rladies_self.bot\",\n                \"mastodon\": None,\n            }\n\n        return None\n\n    def get_config_boost(self):\n        \"\"\"Method to generate config for boosting tags\"\"\"\n        if self.bot == 'pyladies':\n            return {\"client_name\": \"pyladies_self.bot\", \"mastodon\": None}\n\n        if self.bot == 'rladies':\n            if self.platform == \"bluesky\":\n                return {\n                    \"client_name\": \"rladies_self.bot\",\n                    \"api_base_url\": self.platform,\n                    \"mastodon\": None,\n                    \"password\": os.getenv(\"PASSWORD\"),\n                    \"username\": os.getenv(\"USERNAME\"),\n                    \"platform\": self.platform,\n                    \"tags\": \"rladies\",\n                }\n            return {\"client_name\": \"rladies_self.bot\", \"mastodon\": None}\n\n        return None\n\n    def get_config_anniversary(self):\n        \"\"\"Method to get config for promoting anniversaries\"\"\"\n        if self.bot == 'pyladies':\n            if self.platform == 'bluesky':\n                return {\n                    'client_name': 'pyladies_self.bot',\n                    'api_base_url': self.platform,\n                    'mastodon': None,\n                    'password': os.getenv('PYLADIES_BSKY_PASSWORD'),\n                    'username': os.getenv('PYLADIES_BSKY_USERNAME'),\n                    'images': 'anniversary_images',\n                    'platform': self.platform,\n                }\n            return {'client_name': 'pyladies_self.bot', 'mastodon': None}\n\n        if self.bot == 'rladies':\n            if self.platform == 'bluesky':\n                return {\n                    'client_name': 'rladies_self.bot',\n                    'api_base_url': self.platform,\n                    'mastodon': None,\n                    'password': os.getenv('RLADIES_BSKY_PASSWORD'),\n                    'username': os.getenv('RLADIES_BSKY_USERNAME'),\n                    'images': 'anniversary_images',\n                    'platform': self.platform,\n                }\n            return {'client_name': 'rladies_self.bot', 'mastodon': None}\n\n        return None\n</code></pre>"},{"location":"reference/#src.debug.DebugBots.get_config_anniversary","title":"<code>get_config_anniversary()</code>","text":"<p>Method to get config for promoting anniversaries</p> Source code in <code>src/debug.py</code> <pre><code>def get_config_anniversary(self):\n    \"\"\"Method to get config for promoting anniversaries\"\"\"\n    if self.bot == 'pyladies':\n        if self.platform == 'bluesky':\n            return {\n                'client_name': 'pyladies_self.bot',\n                'api_base_url': self.platform,\n                'mastodon': None,\n                'password': os.getenv('PYLADIES_BSKY_PASSWORD'),\n                'username': os.getenv('PYLADIES_BSKY_USERNAME'),\n                'images': 'anniversary_images',\n                'platform': self.platform,\n            }\n        return {'client_name': 'pyladies_self.bot', 'mastodon': None}\n\n    if self.bot == 'rladies':\n        if self.platform == 'bluesky':\n            return {\n                'client_name': 'rladies_self.bot',\n                'api_base_url': self.platform,\n                'mastodon': None,\n                'password': os.getenv('RLADIES_BSKY_PASSWORD'),\n                'username': os.getenv('RLADIES_BSKY_USERNAME'),\n                'images': 'anniversary_images',\n                'platform': self.platform,\n            }\n        return {'client_name': 'rladies_self.bot', 'mastodon': None}\n\n    return None\n</code></pre>"},{"location":"reference/#src.debug.DebugBots.get_config_blog","title":"<code>get_config_blog()</code>","text":"<p>Method to generate config for promoting blog posts</p> Source code in <code>src/debug.py</code> <pre><code>def get_config_blog(self):\n    \"\"\"Method to generate config for promoting blog posts\"\"\"\n    if self.bot == 'pyladies':\n        if self.platform == 'bluesky':\n            return {\n                \"archive\": \"pyladies_archive_directory_bluesky\",\n                \"counter\": \"metadata/pyladies_counter_bluesky.txt\",\n                \"json_file\": \"metadata/pyladies_meta_data.json\",\n                \"client_name\": \"pyladies_self.bot\",\n                \"images\": \"pyladies_images\",\n                \"api_base_url\": self.platform,\n                \"mastodon\": None,\n                \"gen_ai_support\": True,\n                \"gemini_model_name\": \"gemini-2.5-flash\",\n                \"password\": os.getenv(\"PYLADIES_BSKY_PASSWORD\"),\n                \"username\": os.getenv(\"PYLADIES_BSKY_USERNAME\"),\n                \"platform\": self.platform,\n            }\n        return {\n            'archive': 'pyladies_archive_directory',\n            'counter': 'pyladies_counter.txt',\n            'json_file': 'metadata/pyladies_meta_data.json',\n            'client_name': 'pyladies_self.bot',\n            'mastodon': None,\n        }\n\n    if self.bot == 'rladies':\n        if self.platform == 'bluesky':\n            return {\n                \"archive\": \"rladies_archive_directory_bluesky\",\n                \"counter\": \"../metadata/rladies_counter_bluesky.txt\",\n                \"json_file\": \"../metadata/rladies_meta_data.json\",\n                \"client_name\": \"rladies_self.bot\",\n                \"images\": \"rladies_images\",\n                \"api_base_url\": self.platform,\n                \"mastodon\": None,\n                \"password\": os.getenv(\"RLADIES_BSKY_PASSWORD\"),\n                \"username\": os.getenv(\"RLADIES_BSKY_USERNAME\"),\n                \"platform\": self.platform,\n            }\n        return {\n            \"archive\": \"rladies_archive_directory\",\n            \"counter\": \"../metadata/rladies_counter.txt\",\n            \"json_file\": \"../metadata/rladies_meta_data.json\",\n            \"client_name\": \"rladies_self.bot\",\n            \"mastodon\": None,\n        }\n\n    return None\n</code></pre>"},{"location":"reference/#src.debug.DebugBots.get_config_boost","title":"<code>get_config_boost()</code>","text":"<p>Method to generate config for boosting tags</p> Source code in <code>src/debug.py</code> <pre><code>def get_config_boost(self):\n    \"\"\"Method to generate config for boosting tags\"\"\"\n    if self.bot == 'pyladies':\n        return {\"client_name\": \"pyladies_self.bot\", \"mastodon\": None}\n\n    if self.bot == 'rladies':\n        if self.platform == \"bluesky\":\n            return {\n                \"client_name\": \"rladies_self.bot\",\n                \"api_base_url\": self.platform,\n                \"mastodon\": None,\n                \"password\": os.getenv(\"PASSWORD\"),\n                \"username\": os.getenv(\"USERNAME\"),\n                \"platform\": self.platform,\n                \"tags\": \"rladies\",\n            }\n        return {\"client_name\": \"rladies_self.bot\", \"mastodon\": None}\n\n    return None\n</code></pre>"},{"location":"reference/#src.debug.DebugBots.start_debug","title":"<code>start_debug()</code>","text":"<p>Start debugging.</p> Source code in <code>src/debug.py</code> <pre><code>def start_debug(self):\n    \"\"\"Start debugging.\"\"\"\n    if self.what_to_debug == 'blog':\n        config_dict = self.get_config_blog()\n        promote_blog_post_handler = PromoteBlogPost(\n            config_dict,\n            self.no_dry_run\n        )\n        promote_blog_post_handler.promote_blog_post()\n\n    elif self.what_to_debug == 'rss':\n        config_dict = self.get_config_rss()\n        rss_data_handler = RSSData(\n            config_dict,\n            self.no_dry_run\n        )\n        rss_data_handler.get_rss_data()\n\n    elif self.what_to_debug == 'boost_tags':\n        config_dict = self.get_config_boost()\n        boost_tags_handler = BoostTags(\n            config_dict,\n            self.no_dry_run\n        )\n        boost_tags_handler.boost_tags()\n\n    elif self.what_to_debug == 'boost_mentions':\n        config_dict = self.get_config_boost()\n        boost_tags_handler = BoostMentions(\n            config_dict,\n            self.no_dry_run\n        )\n        boost_tags_handler.boost_mentions()\n\n    elif self.what_to_debug == 'anniversary':\n        config_dict = self.get_config_anniversary()\n        promote_anniversary_handler = PromoteAnniversary(\n            config_dict,\n            self.no_dry_run\n        )\n        promote_anniversary_handler.promote_anniversary()\n</code></pre>"},{"location":"reference/#src.get_rss_data","title":"<code>get_rss_data</code>","text":"<p>Module to get RSS metadata from JSON files.</p>"},{"location":"reference/#src.get_rss_data.RSSData","title":"<code>RSSData</code>","text":"<p>Handle gathering RSS data from JSON files.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>class RSSData:\n    \"\"\"\n    Handle gathering RSS data from JSON files.\n    \"\"\"\n\n    def __init__(self, config_dict=None, no_dry_run=True):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n\n        self.config_dict = config_dict or {}\n        self.no_dry_run = no_dry_run\n\n        if self.no_dry_run:\n            self.base_url = os.getenv(\"BASE_URL\")\n            self.github_raw_url = os.getenv(\"GITHUB_RAW_URL\")\n            self.json_file = os.getenv(\"JSON_FILE\")\n        else:\n            self.base_url = self.config_dict.get(\"api_base_url\")\n            self.github_raw_url = self.config_dict.get(\"github_raw_url\")\n            self.json_file = self.config_dict.get(\"json_file\")\n\n    def get_rss_data(self):\n        \"\"\"\n        Retrieve and save RSS metadata.\n        \"\"\"\n        contents_list = self.get_json_data()\n        meta_data = self.get_meta_data(contents_list)\n\n        if self.no_dry_run:\n            with open(self.json_file, \"w\", encoding=\"utf-8\") as fp:\n                json.dump(meta_data, fp, ensure_ascii=False, indent=2)\n\n            self.logger.info(\n                \"Meta data successfully saved to %s\",\n                self.json_file\n            )\n\n    @staticmethod\n    def extract_elements(string: str, suffix: str) -&gt; list[str]:\n        \"\"\"\n        Extract matching substrings from a given string.\n\n        The method searches for substrings enclosed in double quotes (`\"`)\n        that end with the provided suffix, excluding any that contain the word\n        \"blog\".\n\n        Args:\n            string (str): Input text to search through.\n            suffix (str): Suffix pattern to match at the end of elements.\n\n        Returns:\n            list[str]: A list of matched substrings.\n        \"\"\"\n        pattern = rf'\"((?!blog)[^\"]*{suffix})\"'\n        return re.findall(pattern, string)\n\n    def get_json_file_names(self) -&gt; list[str]:\n        \"\"\"\n        Retrieve available JSON file names from the configured base URL.\n\n        The method loads the page at `self.base_url`, extracts embedded\n        JavaScript data inside the `&lt;react-app&gt;` element, and constructs full\n        raw GitHub URLs for each JSON file.\n\n        Returns:\n            list[str]: A list of JSON file URLs.\n\n        Raises:\n            requests.HTTPError: If the request to `self.base_url` fails.\n            json.JSONDecodeError: If the embedded script cannot be parsed\n                                    as JSON.\n            AttributeError: If the expected DOM structure is missing.\n        \"\"\"\n        response = requests.get(self.base_url, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        script_tag = soup.find(\"react-app\").find(\"script\")\n\n        payload = json.loads(script_tag.string)\n        return [\n            f\"{self.github_raw_url}/{item['path'].split('/')[-1]}\"\n            for item in payload[\"payload\"][\"tree\"][\"items\"]\n        ]\n\n    def get_json_data(self) -&gt; list[dict]:\n        \"\"\"\n        Download and parse JSON files from discovered file URLs.\n\n        The method retrieves the list of JSON file URLs via\n        `get_json_file_names()`, fetches each file, and loads it into memory.\n\n        Returns:\n            list[dict]: A list of parsed JSON objects.\n\n        Raises:\n            RuntimeError: If no JSON file URLs were found.\n            requests.HTTPError: If fetching a JSON file fails with an HTTP\n                                error.\n            json.JSONDecodeError: If a response is not valid JSON.\n        \"\"\"\n        json_files = self.get_json_file_names()\n        if not json_files:\n            raise RuntimeError(\"No JSON files found.\")\n\n        contents_list = []\n        for json_file in json_files:\n            try:\n                response = requests.get(json_file, timeout=REQUEST_TIMEOUT)\n                response.raise_for_status()\n                contents_list.append(response.json())\n            except (requests.RequestException, json.JSONDecodeError) as exc:\n                self.logger.warning(\"Could not access %s. %s\", json_file, exc)\n\n        return contents_list\n\n    @staticmethod\n    def extract_info(content: dict) -&gt; dict:\n        \"\"\"\n        Extract metadata information from a single JSON content item.\n\n        The method collects:\n        - `name`: The author's name (first entry in `authors`).\n        - `rss_feed`: RSS feed URL (prefers `rss_feed`, falls back to\n            `rss_feed_youtube`).\n        - `mastodon`: Author's Mastodon handle if available.\n        - `bluesky`: Author's Bluesky handle if available.\n\n        Args:\n            content (dict): Parsed JSON object representing author and\n                            feed data.\n\n        Returns:\n            dict: A dictionary containing metadata fields.\n        \"\"\"\n        rss_feed = [content.get(\"rss_feed\")]\n        rss_feed_yt = [content.get(\"rss_feed_youtube\")]\n\n        rss_feed = [a or b for a, b in zip(rss_feed, rss_feed_yt)]\n        rss_feed = \"\" if rss_feed == [None] else rss_feed\n\n        author = content.get(\"authors\", [{}])[0]\n        name = author.get(\"name\", \"\")\n\n        social_media = author.get(\"social_media\", [{}])[0]\n        mastodon = social_media.get(\"mastodon\", \"\")\n        bluesky = social_media.get(\"bluesky\", \"\")\n\n        return {\n            \"name\": name,\n            \"rss_feed\": rss_feed,\n            \"mastodon\": mastodon,\n            \"bluesky\": bluesky,\n        }\n\n    def get_meta_data(self, contents_list: list[dict]) -&gt; list[dict]:\n        \"\"\"\n        Aggregate metadata from multiple JSON content items.\n\n        Iterates through all content dictionaries, extracts metadata\n        using `extract_info()`, and compiles the results into a list.\n\n        Args:\n            contents_list (list[dict]): List of parsed JSON content\n                                        dictionaries.\n\n        Returns:\n            list[dict]: A list of metadata dictionaries.\n        \"\"\"\n        meta_data = []\n        for content in contents_list:\n            content_data = self.extract_info(content)\n            if content_data:\n                meta_data.append(content_data)\n        return meta_data\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.extract_elements","title":"<code>extract_elements(string, suffix)</code>  <code>staticmethod</code>","text":"<p>Extract matching substrings from a given string.</p> <p>The method searches for substrings enclosed in double quotes (<code>\"</code>) that end with the provided suffix, excluding any that contain the word \"blog\".</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>Input text to search through.</p> required <code>suffix</code> <code>str</code> <p>Suffix pattern to match at the end of elements.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of matched substrings.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>@staticmethod\ndef extract_elements(string: str, suffix: str) -&gt; list[str]:\n    \"\"\"\n    Extract matching substrings from a given string.\n\n    The method searches for substrings enclosed in double quotes (`\"`)\n    that end with the provided suffix, excluding any that contain the word\n    \"blog\".\n\n    Args:\n        string (str): Input text to search through.\n        suffix (str): Suffix pattern to match at the end of elements.\n\n    Returns:\n        list[str]: A list of matched substrings.\n    \"\"\"\n    pattern = rf'\"((?!blog)[^\"]*{suffix})\"'\n    return re.findall(pattern, string)\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.extract_info","title":"<code>extract_info(content)</code>  <code>staticmethod</code>","text":"<p>Extract metadata information from a single JSON content item.</p> <p>The method collects: - <code>name</code>: The author's name (first entry in <code>authors</code>). - <code>rss_feed</code>: RSS feed URL (prefers <code>rss_feed</code>, falls back to     <code>rss_feed_youtube</code>). - <code>mastodon</code>: Author's Mastodon handle if available. - <code>bluesky</code>: Author's Bluesky handle if available.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>dict</code> <p>Parsed JSON object representing author and             feed data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing metadata fields.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>@staticmethod\ndef extract_info(content: dict) -&gt; dict:\n    \"\"\"\n    Extract metadata information from a single JSON content item.\n\n    The method collects:\n    - `name`: The author's name (first entry in `authors`).\n    - `rss_feed`: RSS feed URL (prefers `rss_feed`, falls back to\n        `rss_feed_youtube`).\n    - `mastodon`: Author's Mastodon handle if available.\n    - `bluesky`: Author's Bluesky handle if available.\n\n    Args:\n        content (dict): Parsed JSON object representing author and\n                        feed data.\n\n    Returns:\n        dict: A dictionary containing metadata fields.\n    \"\"\"\n    rss_feed = [content.get(\"rss_feed\")]\n    rss_feed_yt = [content.get(\"rss_feed_youtube\")]\n\n    rss_feed = [a or b for a, b in zip(rss_feed, rss_feed_yt)]\n    rss_feed = \"\" if rss_feed == [None] else rss_feed\n\n    author = content.get(\"authors\", [{}])[0]\n    name = author.get(\"name\", \"\")\n\n    social_media = author.get(\"social_media\", [{}])[0]\n    mastodon = social_media.get(\"mastodon\", \"\")\n    bluesky = social_media.get(\"bluesky\", \"\")\n\n    return {\n        \"name\": name,\n        \"rss_feed\": rss_feed,\n        \"mastodon\": mastodon,\n        \"bluesky\": bluesky,\n    }\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.get_json_data","title":"<code>get_json_data()</code>","text":"<p>Download and parse JSON files from discovered file URLs.</p> <p>The method retrieves the list of JSON file URLs via <code>get_json_file_names()</code>, fetches each file, and loads it into memory.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of parsed JSON objects.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no JSON file URLs were found.</p> <code>HTTPError</code> <p>If fetching a JSON file fails with an HTTP                 error.</p> <code>JSONDecodeError</code> <p>If a response is not valid JSON.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>def get_json_data(self) -&gt; list[dict]:\n    \"\"\"\n    Download and parse JSON files from discovered file URLs.\n\n    The method retrieves the list of JSON file URLs via\n    `get_json_file_names()`, fetches each file, and loads it into memory.\n\n    Returns:\n        list[dict]: A list of parsed JSON objects.\n\n    Raises:\n        RuntimeError: If no JSON file URLs were found.\n        requests.HTTPError: If fetching a JSON file fails with an HTTP\n                            error.\n        json.JSONDecodeError: If a response is not valid JSON.\n    \"\"\"\n    json_files = self.get_json_file_names()\n    if not json_files:\n        raise RuntimeError(\"No JSON files found.\")\n\n    contents_list = []\n    for json_file in json_files:\n        try:\n            response = requests.get(json_file, timeout=REQUEST_TIMEOUT)\n            response.raise_for_status()\n            contents_list.append(response.json())\n        except (requests.RequestException, json.JSONDecodeError) as exc:\n            self.logger.warning(\"Could not access %s. %s\", json_file, exc)\n\n    return contents_list\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.get_json_file_names","title":"<code>get_json_file_names()</code>","text":"<p>Retrieve available JSON file names from the configured base URL.</p> <p>The method loads the page at <code>self.base_url</code>, extracts embedded JavaScript data inside the <code>&lt;react-app&gt;</code> element, and constructs full raw GitHub URLs for each JSON file.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of JSON file URLs.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>If the request to <code>self.base_url</code> fails.</p> <code>JSONDecodeError</code> <p>If the embedded script cannot be parsed                     as JSON.</p> <code>AttributeError</code> <p>If the expected DOM structure is missing.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>def get_json_file_names(self) -&gt; list[str]:\n    \"\"\"\n    Retrieve available JSON file names from the configured base URL.\n\n    The method loads the page at `self.base_url`, extracts embedded\n    JavaScript data inside the `&lt;react-app&gt;` element, and constructs full\n    raw GitHub URLs for each JSON file.\n\n    Returns:\n        list[str]: A list of JSON file URLs.\n\n    Raises:\n        requests.HTTPError: If the request to `self.base_url` fails.\n        json.JSONDecodeError: If the embedded script cannot be parsed\n                                as JSON.\n        AttributeError: If the expected DOM structure is missing.\n    \"\"\"\n    response = requests.get(self.base_url, timeout=REQUEST_TIMEOUT)\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    script_tag = soup.find(\"react-app\").find(\"script\")\n\n    payload = json.loads(script_tag.string)\n    return [\n        f\"{self.github_raw_url}/{item['path'].split('/')[-1]}\"\n        for item in payload[\"payload\"][\"tree\"][\"items\"]\n    ]\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.get_meta_data","title":"<code>get_meta_data(contents_list)</code>","text":"<p>Aggregate metadata from multiple JSON content items.</p> <p>Iterates through all content dictionaries, extracts metadata using <code>extract_info()</code>, and compiles the results into a list.</p> <p>Parameters:</p> Name Type Description Default <code>contents_list</code> <code>list[dict]</code> <p>List of parsed JSON content                         dictionaries.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of metadata dictionaries.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>def get_meta_data(self, contents_list: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Aggregate metadata from multiple JSON content items.\n\n    Iterates through all content dictionaries, extracts metadata\n    using `extract_info()`, and compiles the results into a list.\n\n    Args:\n        contents_list (list[dict]): List of parsed JSON content\n                                    dictionaries.\n\n    Returns:\n        list[dict]: A list of metadata dictionaries.\n    \"\"\"\n    meta_data = []\n    for content in contents_list:\n        content_data = self.extract_info(content)\n        if content_data:\n            meta_data.append(content_data)\n    return meta_data\n</code></pre>"},{"location":"reference/#src.get_rss_data.RSSData.get_rss_data","title":"<code>get_rss_data()</code>","text":"<p>Retrieve and save RSS metadata.</p> Source code in <code>src/get_rss_data.py</code> <pre><code>def get_rss_data(self):\n    \"\"\"\n    Retrieve and save RSS metadata.\n    \"\"\"\n    contents_list = self.get_json_data()\n    meta_data = self.get_meta_data(contents_list)\n\n    if self.no_dry_run:\n        with open(self.json_file, \"w\", encoding=\"utf-8\") as fp:\n            json.dump(meta_data, fp, ensure_ascii=False, indent=2)\n\n        self.logger.info(\n            \"Meta data successfully saved to %s\",\n            self.json_file\n        )\n</code></pre>"},{"location":"reference/#src.helper","title":"<code>helper</code>","text":""},{"location":"reference/#src.helper.check_length_anniversary","title":"<code>check_length_anniversary</code>","text":"<p>Script to check for length of content</p>"},{"location":"reference/#src.helper.check_length_anniversary.check_entries","title":"<code>check_entries(data)</code>","text":"<p>Function to check if the combined length of name, description, and wiki_link exceeds 500 characters</p> Source code in <code>src/helper/check_length_anniversary.py</code> <pre><code>def check_entries(data):\n    \"\"\"\n    Function to check if the combined length of name, description, and wiki_link exceeds 500 characters\n    \"\"\"\n    if not data:\n        return\n\n    for entry in data:\n        # Combine name, description, and wiki_link fields\n        combined_text = \"\"\n        combined_text += f\"Let's meet {entry.get('name', '')} \u2728\\n\\n{entry.get('description', '')}\\n\\n\ud83d\udd17 {entry.get('wiki_link', '')}\"\n        combined_text += f\"\\n\\n#amazingwomeninstem #womeninstem #womenalsoknow #impactthefuture\"\n\n        # Check the length of the combined text\n        if len(combined_text) &gt; 500:\n            print(f\"\ud83d\udea8 Alert: The combined text for '{entry.get('name', 'Unknown')}' exceeds 500 characters!\")\n            print(f\"Combined length: {len(combined_text)} characters.\")\n            print(combined_text)\n            print(f\"Length of description: {len(entry.get('description', ''))}.\")\n            sys.exit(1)  # Exit with an error code to indicate failure\n</code></pre>"},{"location":"reference/#src.helper.check_length_anniversary.load_json","title":"<code>load_json(filename)</code>","text":"<p>Function to load JSON data from a file.</p> Source code in <code>src/helper/check_length_anniversary.py</code> <pre><code>def load_json(filename):\n    \"\"\"\n    Function to load JSON data from a file.\n    \"\"\"\n    try:\n        with open(filename, 'r') as file:\n            return json.load(file)\n    except FileNotFoundError:\n        print(f\"Error: The file '{filename}' was not found.\")\n        return None\n    except json.JSONDecodeError:\n        print(f\"Error: The file '{filename}' contains invalid JSON.\")\n        return None\n</code></pre>"},{"location":"reference/#src.helper.login_bluesky","title":"<code>login_bluesky</code>","text":"<p>Module to login to Bluesky</p>"},{"location":"reference/#src.helper.login_mastodon","title":"<code>login_mastodon</code>","text":"<p>Module to log into Mastodon</p>"},{"location":"reference/#src.promote_anniversaries","title":"<code>promote_anniversaries</code>","text":"<p>Module to promote anniversaries on Mastodon and Bluesky. Handles fetching events, building posts, and posting to platforms.</p>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary","title":"<code>PromoteAnniversary</code>","text":"<p>Handles fetching event data and posting anniversary messages to social platforms.</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>class PromoteAnniversary:\n    \"\"\"\n    Handles fetching event data and posting anniversary messages\n    to social platforms.\n    \"\"\"\n    def __init__(self, config_dict=None, no_dry_run=True):\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n        self.config_dict = config_dict\n        self.no_dry_run = no_dry_run\n\n    def promote_anniversary(self):\n        \"\"\"\n        Method to promote anniversaries on social media.\n        \"\"\"\n        if (self.config_dict is None) and (self.no_dry_run):\n            self.config_dict = {\n                \"platform\": os.getenv(\"PLATFORM\"),\n                \"images\": os.getenv(\"IMAGES\"),\n                \"password\": os.getenv(\"PASSWORD\"),\n                \"username\": os.getenv(\"USERNAME\"),\n                \"client_name\": os.getenv(\"CLIENT_NAME\")\n            }\n            if self.config_dict[\"platform\"] == \"mastodon\":\n                self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n                self.config_dict[\n                    \"mastodon_visibility\"\n                ] = config.MASTODON_VISIBILITY\n                self.config_dict[\"client_id\"] = os.getenv(\"CLIENT_ID\")\n                self.config_dict[\"client_secret\"] = os.getenv(\"CLIENT_SECRET\")\n                self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n                self.config_dict[\n                    \"client_cred_file\"\n                ] = os.getenv('BOT_CLIENTCRED_SECRET')\n            else:\n                self.config_dict[\"api_base_url\"] = \"bluesky\"\n\n        if self.no_dry_run:\n            self.logger.info(\"\")\n            self.logger.info(\n                \"Initializing %s Bot\",\n                self.config_dict[\"client_name\"]\n            )\n            self.logger.info(\n                \"%s\",\n                \"=\" * (len(self.config_dict[\"client_name\"]) + 17)\n            )\n            self.logger.info(\n                \" &gt; Connecting to %s\",\n                self.config_dict[\"api_base_url\"]\n            )\n\n            if self.config_dict[\"platform\"] == \"mastodon\":\n                _, client = login_mastodon(self.config_dict)\n            elif self.config_dict[\"platform\"] == \"bluesky\":\n                client = login_bluesky(self.config_dict)\n        else:\n            client = None\n\n        with open('metadata/events.json', encoding='utf-8') as f:\n            events = json.load(f)\n\n        if self.no_dry_run:\n            for event in events:\n                if self.is_matching_current_date(event[\"date\"]):\n                    self.send_post(event, client)\n                    continue\n                    # if  self.config_dict[\"platform\"] == \"mastodon\":\n                    #     send_post_to_mastodon(\n                    #         event,\n                    #         self.config_dict,\n                    #         client\n                    #     )\n                    #     continue\n                    # elif  self.config_dict[\"platform\"] == \"bluesky\":\n                    #     send_post_to_bluesky(\n                    #         event,\n                    #         self.config_dict,\n                    #         client\n                    #     )\n                    #    continue\n\n    @staticmethod\n    def is_matching_current_date(date_str: str, date_format='%m-%d') -&gt; bool:\n        \"\"\"\n        Method to define if the event matches the current date and\n        should be posted.\n\n        Args:\n            date_str (str): Date taken from event dictionary\n            date_format (str, optional): _description_. Defaults to '%m-%d'.\n\n        Returns:\n            bool: Defines whether the date matches the current date\n                (True if yes)\n        \"\"\"\n        current_date = datetime.now().strftime(date_format)\n        return date_str == current_date\n\n    def download_image(self, url: str) -&gt; str:\n        \"\"\"\n        Method downloads images. It's heavily inspired by:\n        https://github.com/zeratax/mastodon-img-bot/blob/master/bot.py\n\n        Args:\n            url: string with the url to the image\n\n        Returns:\n            string with the path to the saved image\n        \"\"\"\n        path = urlsplit(url).path\n        filename = posixpath.basename(path)\n\n        file_path = f\"{self.config_dict['images']}/{filename}\"\n        if not os.path.isfile(file_path):\n            if not os.path.isdir(self.config_dict['images']):\n                os.makedirs(self.config_dict['images'])\n\n            headers = {\n                'User-Agent': (\n                    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) '\n                    'Gecko/20100101 Firefox/20.0'\n                )\n            }\n            response = requests.get(\n                url,\n                headers=headers,\n                stream=True,\n                timeout=REQUEST_TIMEOUT\n            )\n\n            with open(file_path, 'wb') as out_file:\n                shutil.copyfileobj(\n                    response.raw, out_file)\n            del response\n        else:\n            print(\"Image already downloaded\")\n        return file_path\n\n    def build_post(self, event: dict):\n        \"\"\"Method to build the toot\n\n        Args:\n            event (dict): Dictionary with information\n\n        Returns:\n            Toot text\n        \"\"\"\n        tags = \"\\n\\n#amazingwomenintech #womenalsoknow #impactthefuture\"\n\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            toot_str = \"\"\n            toot_str += (\n                f\"Let's meet {event['name']} \u2728\\n\\n\"\n                f\"{event['description_mastodon']}\\n\\n\"\n                f\"\ud83d\udd17 {event['wiki_link']}\"\n            )\n            toot_str += tags\n            return toot_str\n        if self.config_dict[\"platform\"] == \"bluesky\":\n            text_builder = client_utils.TextBuilder()\n            if event[\"bluesky\"]:\n                did = self.get_bluesky_did(event[\"bluesky\"])\n                text_builder.text(\"Let's meet \")\n                text_builder.mention(f\"{event['bluesky']}\", did)\n                text_builder.text(\" \u2b50\ufe0f\\n\\n\")\n            else:\n                text_builder.text(f\"Let's meet {event['name']} \u2b50\ufe0f\\n\\n\")\n            split_text = re.split(r'(#\\w+)', event[\"description_bluesky\"])\n            split_text = [\n                item.rstrip(' ')\n                for item in split_text\n                if item.strip()\n            ]\n            for text_chunk in split_text:\n                if text_chunk.startswith('#'):\n                    for tag in text_chunk.split(\"#\"):\n                        tag_clean = tag.strip()\n                    if tag_clean:\n                        text_builder.tag(f\"#{tag_clean}\", tag_clean)\n                else:\n                    text_chunk_clean = self.add_whitespace_if_needed(\n                        text_chunk\n                    )\n                    text_builder.text(text_chunk_clean)\n            text_builder.text('\\n\\n\ud83d\udd17 ')\n            text_builder.link(event[\"wiki_link\"], event[\"wiki_link\"])\n            text_builder.text('\\n\\n')\n            for tag in tags.split(\"#\"):\n                tag_clean = tag.strip()\n                if tag_clean:\n                    text_builder.tag(f\"#{tag_clean} \", tag_clean)\n            return text_builder\n\n    def send_post(self, event, client):\n        \"\"\"Send a post to the configured platform (Mastodon or Bluesky).\"\"\"\n\n        self.logger.info(\n            \"\"\"\n            Preparing the post on %s (%s) ...\n            \"\"\",\n            self.config_dict['client_name'],\n            self.config_dict['platform']\n        )\n\n        post_txt = self.build_post(event)\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            self.send_post_to_mastodon(event, client, post_txt)\n        elif self.config_dict[\"platform\"] == \"bluesky\":\n            embed_external = self.build_embed_external(event, client)\n            self.send_post_to_bluesky(event, client, post_txt, embed_external)\n\n    def build_embed_external(self, event, client):\n        \"\"\"Build external embed object for Bluesky posts.\"\"\"\n        repo_url = (\n            \"https://raw.githubusercontent.com/cosimameyer/illustrations/main\"\n        )\n        base_path = f\"{repo_url}/amazing-women\"\n        url = f\"{base_path}/{event['img']}\"\n        filename = self.download_image(url)\n        with open(filename, 'rb') as f:\n            img_data = f.read()\n\n        thumb = client.upload_blob(img_data)\n\n        return models.AppBskyEmbedExternal.Main(\n            external=models.AppBskyEmbedExternal.External(\n                title=f\"Image of {event['name']}\",\n                description=event[\"alt\"],\n                uri=url,\n                thumb=thumb.blob,\n            )\n        )\n\n    @staticmethod\n    def get_bluesky_did(platform_user_handle: str):\n        \"\"\"\n        Method to extract the Bluesky specific unique user ID (`did`).\n\n        Args:\n            platform_user_handle (str): User handle of bluesky\n\n        Returns:\n            str: did\n        \"\"\"\n        url = (\n            f\"https://bsky.social/xrpc/com.atproto.identity.resolveHandle?\"\n            f\"handle={platform_user_handle.lstrip('@')}\"\n        )\n        try:\n            response = requests.get(\n                url,\n                timeout=REQUEST_TIMEOUT\n            )\n\n            if response.status_code == 200:\n                data = response.json()\n\n                did = data.get(\"did\")\n\n                if did:\n                    return did\n                print(\"The 'did' field was not found in the response.\")\n            print(\n                f\"Failed to retrieve data. Status code: {response.status_code}\"\n            )\n\n        except requests.RequestException as e:\n            print(\"An error occurred:\", e)\n\n    def send_post_to_bluesky(self, event, client, post_txt, embed_external):\n        \"\"\"Send a post to Bluesky with optional media embed.\"\"\"\n        self.logger.info(\n            'Preview your post...\\n\\n%s',\n            post_txt._buffer.getvalue().decode('utf-8')\n        )\n        try:\n            client.send_post(text=post_txt, embed=embed_external)\n            self.logger.info(\"Posted \ud83c\udf89\")\n        except Exception as e:\n            self.logger.exception(\"Urg, exception %s for %s\", e, event['name'])\n\n    @staticmethod\n    def add_whitespace_if_needed(text_chunk):\n        if not text_chunk.endswith(('(', '{', '[')):\n            text_chunk += ' '\n        return text_chunk\n\n    def send_post_to_mastodon(self, event, client, post_txt):\n        \"\"\"Send a post to Mastodon, with media if available.\"\"\"\n        if event['img']:\n            try:\n                print(\"Uploading media to mastodon\")\n                base_path = (\n                    \"https://raw.githubusercontent.com/\"\n                    \"cosimameyer/illustrations/main/\"\n                    \"amazing-women\"\n                )\n                url = f\"{base_path}/{event['img']}\"\n\n                filename = self.download_image(url)\n                media_upload_mastodon = client.media_post(filename)\n\n                print(\"adding description\")\n                if event[\"alt\"]:\n                    client.media_update(media_upload_mastodon,\n                                        description=event[\"alt\"])\n                else:\n                    client.media_update(media_upload_mastodon,\n                                        description=str(event[\"name\"]))\n\n                print(\"ready to post\")\n                client.status_post(\n                    post_txt,\n                    media_ids=media_upload_mastodon\n                )\n\n                print(\"posted\")\n            except Exception as e:\n                self.logger.info(\n                    \"\"\"\n                    Urg, media could not be printed.\\n\n                    Exception %s because of %s\n                    \"\"\",\n                    event['name'],\n                    e\n                )\n                client.status_post(post_txt)\n                self.logger.info(\"Posted toot without image.\")\n        else:\n            try:\n                client.status_post(post_txt)\n                self.logger.info(\"posted\")\n            except Exception as e:\n                self.logger.info(\n                    \"Urg, exception %s. The reason was %s\",\n                    event['toot'],\n                    e\n                )\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.build_embed_external","title":"<code>build_embed_external(event, client)</code>","text":"<p>Build external embed object for Bluesky posts.</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def build_embed_external(self, event, client):\n    \"\"\"Build external embed object for Bluesky posts.\"\"\"\n    repo_url = (\n        \"https://raw.githubusercontent.com/cosimameyer/illustrations/main\"\n    )\n    base_path = f\"{repo_url}/amazing-women\"\n    url = f\"{base_path}/{event['img']}\"\n    filename = self.download_image(url)\n    with open(filename, 'rb') as f:\n        img_data = f.read()\n\n    thumb = client.upload_blob(img_data)\n\n    return models.AppBskyEmbedExternal.Main(\n        external=models.AppBskyEmbedExternal.External(\n            title=f\"Image of {event['name']}\",\n            description=event[\"alt\"],\n            uri=url,\n            thumb=thumb.blob,\n        )\n    )\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.build_post","title":"<code>build_post(event)</code>","text":"<p>Method to build the toot</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>Dictionary with information</p> required <p>Returns:</p> Type Description <p>Toot text</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def build_post(self, event: dict):\n    \"\"\"Method to build the toot\n\n    Args:\n        event (dict): Dictionary with information\n\n    Returns:\n        Toot text\n    \"\"\"\n    tags = \"\\n\\n#amazingwomenintech #womenalsoknow #impactthefuture\"\n\n    if self.config_dict[\"platform\"] == \"mastodon\":\n        toot_str = \"\"\n        toot_str += (\n            f\"Let's meet {event['name']} \u2728\\n\\n\"\n            f\"{event['description_mastodon']}\\n\\n\"\n            f\"\ud83d\udd17 {event['wiki_link']}\"\n        )\n        toot_str += tags\n        return toot_str\n    if self.config_dict[\"platform\"] == \"bluesky\":\n        text_builder = client_utils.TextBuilder()\n        if event[\"bluesky\"]:\n            did = self.get_bluesky_did(event[\"bluesky\"])\n            text_builder.text(\"Let's meet \")\n            text_builder.mention(f\"{event['bluesky']}\", did)\n            text_builder.text(\" \u2b50\ufe0f\\n\\n\")\n        else:\n            text_builder.text(f\"Let's meet {event['name']} \u2b50\ufe0f\\n\\n\")\n        split_text = re.split(r'(#\\w+)', event[\"description_bluesky\"])\n        split_text = [\n            item.rstrip(' ')\n            for item in split_text\n            if item.strip()\n        ]\n        for text_chunk in split_text:\n            if text_chunk.startswith('#'):\n                for tag in text_chunk.split(\"#\"):\n                    tag_clean = tag.strip()\n                if tag_clean:\n                    text_builder.tag(f\"#{tag_clean}\", tag_clean)\n            else:\n                text_chunk_clean = self.add_whitespace_if_needed(\n                    text_chunk\n                )\n                text_builder.text(text_chunk_clean)\n        text_builder.text('\\n\\n\ud83d\udd17 ')\n        text_builder.link(event[\"wiki_link\"], event[\"wiki_link\"])\n        text_builder.text('\\n\\n')\n        for tag in tags.split(\"#\"):\n            tag_clean = tag.strip()\n            if tag_clean:\n                text_builder.tag(f\"#{tag_clean} \", tag_clean)\n        return text_builder\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.download_image","title":"<code>download_image(url)</code>","text":"<p>Method downloads images. It's heavily inspired by: https://github.com/zeratax/mastodon-img-bot/blob/master/bot.py</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>string with the url to the image</p> required <p>Returns:</p> Type Description <code>str</code> <p>string with the path to the saved image</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def download_image(self, url: str) -&gt; str:\n    \"\"\"\n    Method downloads images. It's heavily inspired by:\n    https://github.com/zeratax/mastodon-img-bot/blob/master/bot.py\n\n    Args:\n        url: string with the url to the image\n\n    Returns:\n        string with the path to the saved image\n    \"\"\"\n    path = urlsplit(url).path\n    filename = posixpath.basename(path)\n\n    file_path = f\"{self.config_dict['images']}/{filename}\"\n    if not os.path.isfile(file_path):\n        if not os.path.isdir(self.config_dict['images']):\n            os.makedirs(self.config_dict['images'])\n\n        headers = {\n            'User-Agent': (\n                'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) '\n                'Gecko/20100101 Firefox/20.0'\n            )\n        }\n        response = requests.get(\n            url,\n            headers=headers,\n            stream=True,\n            timeout=REQUEST_TIMEOUT\n        )\n\n        with open(file_path, 'wb') as out_file:\n            shutil.copyfileobj(\n                response.raw, out_file)\n        del response\n    else:\n        print(\"Image already downloaded\")\n    return file_path\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.get_bluesky_did","title":"<code>get_bluesky_did(platform_user_handle)</code>  <code>staticmethod</code>","text":"<p>Method to extract the Bluesky specific unique user ID (<code>did</code>).</p> <p>Parameters:</p> Name Type Description Default <code>platform_user_handle</code> <code>str</code> <p>User handle of bluesky</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>did</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>@staticmethod\ndef get_bluesky_did(platform_user_handle: str):\n    \"\"\"\n    Method to extract the Bluesky specific unique user ID (`did`).\n\n    Args:\n        platform_user_handle (str): User handle of bluesky\n\n    Returns:\n        str: did\n    \"\"\"\n    url = (\n        f\"https://bsky.social/xrpc/com.atproto.identity.resolveHandle?\"\n        f\"handle={platform_user_handle.lstrip('@')}\"\n    )\n    try:\n        response = requests.get(\n            url,\n            timeout=REQUEST_TIMEOUT\n        )\n\n        if response.status_code == 200:\n            data = response.json()\n\n            did = data.get(\"did\")\n\n            if did:\n                return did\n            print(\"The 'did' field was not found in the response.\")\n        print(\n            f\"Failed to retrieve data. Status code: {response.status_code}\"\n        )\n\n    except requests.RequestException as e:\n        print(\"An error occurred:\", e)\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.is_matching_current_date","title":"<code>is_matching_current_date(date_str, date_format='%m-%d')</code>  <code>staticmethod</code>","text":"<p>Method to define if the event matches the current date and should be posted.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date taken from event dictionary</p> required <code>date_format</code> <code>str</code> <p>description. Defaults to '%m-%d'.</p> <code>'%m-%d'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Defines whether the date matches the current date (True if yes)</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>@staticmethod\ndef is_matching_current_date(date_str: str, date_format='%m-%d') -&gt; bool:\n    \"\"\"\n    Method to define if the event matches the current date and\n    should be posted.\n\n    Args:\n        date_str (str): Date taken from event dictionary\n        date_format (str, optional): _description_. Defaults to '%m-%d'.\n\n    Returns:\n        bool: Defines whether the date matches the current date\n            (True if yes)\n    \"\"\"\n    current_date = datetime.now().strftime(date_format)\n    return date_str == current_date\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.promote_anniversary","title":"<code>promote_anniversary()</code>","text":"<p>Method to promote anniversaries on social media.</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def promote_anniversary(self):\n    \"\"\"\n    Method to promote anniversaries on social media.\n    \"\"\"\n    if (self.config_dict is None) and (self.no_dry_run):\n        self.config_dict = {\n            \"platform\": os.getenv(\"PLATFORM\"),\n            \"images\": os.getenv(\"IMAGES\"),\n            \"password\": os.getenv(\"PASSWORD\"),\n            \"username\": os.getenv(\"USERNAME\"),\n            \"client_name\": os.getenv(\"CLIENT_NAME\")\n        }\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n            self.config_dict[\n                \"mastodon_visibility\"\n            ] = config.MASTODON_VISIBILITY\n            self.config_dict[\"client_id\"] = os.getenv(\"CLIENT_ID\")\n            self.config_dict[\"client_secret\"] = os.getenv(\"CLIENT_SECRET\")\n            self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n            self.config_dict[\n                \"client_cred_file\"\n            ] = os.getenv('BOT_CLIENTCRED_SECRET')\n        else:\n            self.config_dict[\"api_base_url\"] = \"bluesky\"\n\n    if self.no_dry_run:\n        self.logger.info(\"\")\n        self.logger.info(\n            \"Initializing %s Bot\",\n            self.config_dict[\"client_name\"]\n        )\n        self.logger.info(\n            \"%s\",\n            \"=\" * (len(self.config_dict[\"client_name\"]) + 17)\n        )\n        self.logger.info(\n            \" &gt; Connecting to %s\",\n            self.config_dict[\"api_base_url\"]\n        )\n\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            _, client = login_mastodon(self.config_dict)\n        elif self.config_dict[\"platform\"] == \"bluesky\":\n            client = login_bluesky(self.config_dict)\n    else:\n        client = None\n\n    with open('metadata/events.json', encoding='utf-8') as f:\n        events = json.load(f)\n\n    if self.no_dry_run:\n        for event in events:\n            if self.is_matching_current_date(event[\"date\"]):\n                self.send_post(event, client)\n                continue\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.send_post","title":"<code>send_post(event, client)</code>","text":"<p>Send a post to the configured platform (Mastodon or Bluesky).</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def send_post(self, event, client):\n    \"\"\"Send a post to the configured platform (Mastodon or Bluesky).\"\"\"\n\n    self.logger.info(\n        \"\"\"\n        Preparing the post on %s (%s) ...\n        \"\"\",\n        self.config_dict['client_name'],\n        self.config_dict['platform']\n    )\n\n    post_txt = self.build_post(event)\n    if self.config_dict[\"platform\"] == \"mastodon\":\n        self.send_post_to_mastodon(event, client, post_txt)\n    elif self.config_dict[\"platform\"] == \"bluesky\":\n        embed_external = self.build_embed_external(event, client)\n        self.send_post_to_bluesky(event, client, post_txt, embed_external)\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.send_post_to_bluesky","title":"<code>send_post_to_bluesky(event, client, post_txt, embed_external)</code>","text":"<p>Send a post to Bluesky with optional media embed.</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def send_post_to_bluesky(self, event, client, post_txt, embed_external):\n    \"\"\"Send a post to Bluesky with optional media embed.\"\"\"\n    self.logger.info(\n        'Preview your post...\\n\\n%s',\n        post_txt._buffer.getvalue().decode('utf-8')\n    )\n    try:\n        client.send_post(text=post_txt, embed=embed_external)\n        self.logger.info(\"Posted \ud83c\udf89\")\n    except Exception as e:\n        self.logger.exception(\"Urg, exception %s for %s\", e, event['name'])\n</code></pre>"},{"location":"reference/#src.promote_anniversaries.PromoteAnniversary.send_post_to_mastodon","title":"<code>send_post_to_mastodon(event, client, post_txt)</code>","text":"<p>Send a post to Mastodon, with media if available.</p> Source code in <code>src/promote_anniversaries.py</code> <pre><code>def send_post_to_mastodon(self, event, client, post_txt):\n    \"\"\"Send a post to Mastodon, with media if available.\"\"\"\n    if event['img']:\n        try:\n            print(\"Uploading media to mastodon\")\n            base_path = (\n                \"https://raw.githubusercontent.com/\"\n                \"cosimameyer/illustrations/main/\"\n                \"amazing-women\"\n            )\n            url = f\"{base_path}/{event['img']}\"\n\n            filename = self.download_image(url)\n            media_upload_mastodon = client.media_post(filename)\n\n            print(\"adding description\")\n            if event[\"alt\"]:\n                client.media_update(media_upload_mastodon,\n                                    description=event[\"alt\"])\n            else:\n                client.media_update(media_upload_mastodon,\n                                    description=str(event[\"name\"]))\n\n            print(\"ready to post\")\n            client.status_post(\n                post_txt,\n                media_ids=media_upload_mastodon\n            )\n\n            print(\"posted\")\n        except Exception as e:\n            self.logger.info(\n                \"\"\"\n                Urg, media could not be printed.\\n\n                Exception %s because of %s\n                \"\"\",\n                event['name'],\n                e\n            )\n            client.status_post(post_txt)\n            self.logger.info(\"Posted toot without image.\")\n    else:\n        try:\n            client.status_post(post_txt)\n            self.logger.info(\"posted\")\n        except Exception as e:\n            self.logger.info(\n                \"Urg, exception %s. The reason was %s\",\n                event['toot'],\n                e\n            )\n</code></pre>"},{"location":"reference/#src.promote_blog_post","title":"<code>promote_blog_post</code>","text":"<p>Promote blog posts</p>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost","title":"<code>PromoteBlogPost</code>","text":"<p>Class to handle promoting blog posts by the community bots.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>class PromoteBlogPost():\n    \"\"\"\n    Class to handle promoting blog posts by the community bots.\n    \"\"\"\n    def __init__(self, config_dict=None, no_dry_run=True):\n        self.logger = logging.getLogger(__name__)\n        logging.basicConfig(level=logging.INFO)\n\n        self.process_images = False\n        self.no_dry_run = no_dry_run\n        self.config_dict = config_dict\n\n    def get_config(self):\n        \"\"\"\n        Get config file\n        \"\"\"\n        if (self.config_dict is None) and (self.no_dry_run):\n            self.config_dict = {\n                \"platform\": os.getenv(\"PLATFORM\"),\n                \"archive\": os.getenv(\"ARCHIVE_DIRECTORY\"),\n                \"images\": os.getenv(\"IMAGES\"),\n                \"counter\": self._ensure_metadata_prefix(\n                    os.getenv(\"COUNTER\", \"\")\n                ),\n                \"password\": os.getenv(\"PASSWORD\"),\n                \"username\": os.getenv(\"USERNAME\"),\n                \"client_name\": os.getenv(\"CLIENT_NAME\"),\n                \"json_file\": self._ensure_metadata_prefix(\n                    os.getenv(\"JSON_FILE\", \"\")\n                ),\n                \"gen_ai_support\": True,\n                \"gemini_api_key\": os.getenv(\"GEMINI_API_KEY\"),\n                \"gemini_model_name\": \"gemini-2.5-flash\"\n            }\n            if self.config_dict[\"platform\"] == \"mastodon\":\n                self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n                self.config_dict[\"mastodon_visibility\"] = (\n                    config.MASTODON_VISIBILITY\n                )\n                self.config_dict[\"client_id\"] = os.getenv(\"CLIENT_ID\")\n                self.config_dict[\"client_secret\"] = os.getenv(\"CLIENT_SECRET\")\n                self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n                self.config_dict[\"client_cred_file\"] = os.getenv(\n                    'BOT_CLIENTCRED_SECRET'\n                )\n            else:\n                self.config_dict[\"api_base_url\"] = \"bluesky\"\n\n            if self.config_dict[\"gen_ai_support\"]:\n                genai.configure(api_key=self.config_dict[\"gemini_api_key\"])\n        else:\n            self.config_dict['json_file'] = self._ensure_metadata_prefix(\n                self.config_dict.get('json_file')\n            )\n            self.config_dict['counter'] = self._ensure_metadata_prefix(\n                self.config_dict.get('counter')\n            )\n\n    def promote_blog_post(self):\n        \"\"\"Core method to promote blog post\"\"\"\n\n        self.get_config()\n\n        if self.no_dry_run:\n            client_name = self.config_dict.get('client_name', 'unknown')\n            self.logger.info(\"\")\n            self.logger.info(\n                'Initializing %s Bot',\n                client_name\n            )\n            separator = \"%s\", \"=\" * (len(client_name) + 17)\n            self.logger.info(separator)\n            self.logger.info(\n                \" &gt; Connecting to %s\",\n                self.config_dict.get('api_base_url', '')\n            )\n\n            if self.config_dict[\"platform\"] == \"mastodon\":\n                _, client = login_mastodon(self.config_dict)\n            elif self.config_dict[\"platform\"] == \"bluesky\":\n                client = login_bluesky(self.config_dict)\n        else:\n            client = None\n\n        feeds = self.read_metadata_json()\n        counter_name = self.read_counter_name()\n\n        # Initiate count to post a maximum of 2 posts per run\n        count_post = 0\n\n        # Drop empty rss_feeds\n        feeds = [x for x in feeds if x['rss_feed'] != '']\n\n        if self.no_dry_run:\n            self.process_feeds(feeds, counter_name, count_post, client)\n        else:\n            for feed in feeds:\n                count_post = self.process_feed(\n                    feed,\n                    count_post,\n                    client\n                )\n\n    def process_feeds(self, feeds, counter_name, count_post, client):\n        \"\"\"\n        Method to handle processing of all feeds.\n        \"\"\"\n        for feed in feeds:\n            if counter_name not in (feed['name'], '\\n', ''):\n                continue\n            if len(feed['rss_feed']) == 0 or feed['rss_feed'] == [None]:\n                continue\n\n            is_last_feed = feed['name'] == feeds[-1]['name']\n\n            if count_post == 0 and is_last_feed:\n                count_post = self.process_feed(\n                    feed,\n                    count_post,\n                    client\n                )\n\n                # Add the counter_name\n                if is_last_feed:\n                    new_feed = feeds[0]\n                    count_post = self.process_feed(\n                        new_feed,\n                        count_post,\n                        client\n                    )\n\n                    self.logger.info(\n                        \"Successfully promoted blog posts. \"\n                        \"Thank you and see you next time!\")\n                    self.update_counter(feeds[1]['name'])\n                    break\n\n            elif count_post &lt; 2:\n                count_post = self.process_feed(\n                    feed,\n                    count_post,\n                    client\n                )\n                counter_name = ''\n                if is_last_feed:\n                    self.update_counter(feed['name'])\n                self.logger.info(\n                    \"=========================================\")\n\n            else:\n                self.logger.info(\n                    \"Successfully promoted blog posts. \"\n                    \"Thank you and see you next time!\")\n                self.update_counter(feed['name'])\n                break\n\n    def update_counter(self, counter_name):\n        \"\"\"\n        Update counter name\n        \"\"\"\n        with open(\n            self.config_dict[\"counter\"],\n            'w',\n            encoding='utf-8'\n        ) as txt_file:\n            txt_file.write(counter_name)\n\n    def read_counter_name(self):\n        \"\"\"\n        Read counter name from txt file\n        \"\"\"\n        with open(self.config_dict[\"counter\"], 'r', encoding='utf-8') as f:\n            return f.read()\n\n    def read_metadata_json(self):\n        \"\"\"\n        Read metadata JSON file\n        \"\"\"\n        with open(self.config_dict[\"json_file\"], 'rb') as fp:\n            self.logger.info(\n                \"=============================================\"\n            )\n            feeds = json.load(fp)\n            self.logger.info('Meta data was successfully loaded')\n            self.logger.info(\n                \"=============================================\"\n            )\n            return feeds\n\n    @staticmethod\n    def _ensure_metadata_prefix(value: str, prefix=\"metadata/\") -&gt; str:\n        \"\"\"\n        Ensures that a string has the prefix \"metadata/\". If it does not\n        have this, update it.\n        \"\"\"\n        if not value.startswith(prefix):\n            return prefix + value\n        return value\n\n    def download_image(self, url: str):\n        \"\"\"\n        Downloads an image from the given URL and saves it locally,\n        organizing files by domain name.\n        \"\"\"\n        try:\n            filename = ''\n            # Parse the URL components\n            if self.config_dict[\"platform\"] == \"bluesky\":\n                domain = urlsplit(url).path\n                filename = posixpath.basename(domain)\n            elif self.config_dict[\"platform\"] == \"mastodon\":\n                domain = urlsplit(url).netloc\n                filename = posixpath.basename(urlsplit(url).path)\n\n            # Create folder structure based on the domain name\n            domain_dir = Path(self.config_dict['images']) / domain\n            domain_dir.mkdir(parents=True, exist_ok=True)\n\n            # Full file path for the image\n            file_path = domain_dir / filename\n\n            if file_path.is_file():\n                self.logger.info(\"Image already downloaded: %s\", file_path)\n                return str(file_path)\n\n            # Set user-agent headers for the request\n            headers = {\n                'User-Agent': (\n                    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) '\n                    'Gecko/20100101 Firefox/20.0'\n                )\n            }\n\n            # Download the image\n            self.logger.info(\"Downloading image from %s...\", url)\n            response = requests.get(\n                url,\n                headers=headers,\n                stream=True,\n                timeout=15\n            )\n            response.raise_for_status()  # Raises an exception for HTTP errors\n\n            # Save the image to the designated path\n            with open(file_path, 'wb') as out_file:\n                shutil.copyfileobj(response.raw, out_file)\n\n            self.logger.info(\"Image successfully downloaded: %s\", file_path)\n            return str(file_path)\n\n        except requests.exceptions.RequestException as e:\n            self.logger.error(\"Failed to download image from %s: %e\", url, e)\n            return None\n        except OSError as e:\n            self.logger.error(\"File system error while saving image: %s\", e)\n            return None\n        finally:\n            if 'response' in locals():\n                response.close()\n\n    def parse_pub_date(self, entry):\n        \"\"\"Method to parse the publication date\"\"\"\n        date_formats = [\n            \"%a, %d %b %Y %H:%M:%S %z\",  # Format 1\n            \"%a, %d %b %Y %H:%M:%S %Z\",  # Format 2\n            \"%Y-%m-%d\",                  # Format 3\n            \"%Y-%m-%dT%H:%M:%S.%f%Z\"     # Format 4\n        ]\n\n        pub_date_str = entry.get('pub_date', '')\n\n        for date_format in date_formats:\n            try:\n                pub_date = datetime.strptime(\n                    pub_date_str, date_format).replace(tzinfo=None)\n                return pub_date  # Return as soon as a valid format is found\n            except ValueError:\n                self.logger.info(\n                    \"Failed to parse date with format: %s\",\n                    date_format\n                )\n\n        # If none of the formats match, use the current date as a fallback\n        self.logger.warning(\n            \"No matching date format found. Using current date.\"\n        )\n        return datetime.now()  # Fallback value\n\n    def define_tags(self, entry):\n        \"\"\"\n        Define tags that will be posted along the posts.\n        \"\"\"\n        if self.config_dict.get('client_name', '') == 'pyladies_bot':\n            tags = '#pyladies #python '\n        elif self.config_dict.get('client_name', '') == 'rladies_bot':\n            tags = '#rladies #rstats '\n        else:\n            self.logger.info('Bot name not found')\n            tags = ''\n\n        pub_date = self.parse_pub_date(entry)\n\n        age_of_post = datetime.now() - pub_date\n\n        if age_of_post.days &gt; 730:\n            tags += '#oldiebutgoodie '\n\n        if len(entry['tags']) &gt; 0:\n            for tag in entry['tags']:\n                if tag.lower() in ['pyladies', 'python', 'rstats', 'rladies']:\n                    pass\n                else:\n                    tags += (\n                        f\"#{tag.replace(' ', '').replace('-', '').lower()} \"\n                    )\n\n        return tags\n\n    def get_bluesky_did(self, platform_user_handle):\n        \"\"\"\n        Method to get Bluesky DID to uniquely identify (and tag) user.\n        \"\"\"\n        url = (\n            f\"https://bsky.social/xrpc/com.atproto.identity.resolveHandle?\"\n            f\"handle={platform_user_handle.lstrip('@')}\"\n        )\n        try:\n            response = requests.get(url)\n\n            if response.status_code == 200:\n                data = response.json()\n                did = data.get('did', None)\n\n                if did:\n                    return did\n                else:\n                    self.logger.info(\n                        'The \"did\" field was not found in the response.'\n                    )\n            else:\n                self.logger.info(\n                    'Failed to retrieve data. Status code: %s',\n                    response.status_code\n                )\n\n        except requests.RequestException as e:\n            self.logger.info('An error occurred: %s', e)\n\n    def build_post_mastodon(\n        self, basis_text, platform_user_handle, tags, entry\n    ):\n        \"\"\"\n        Build Mastodon post.\n        \"\"\"\n        platform_user_handle = self.check_platform_handle(platform_user_handle)\n\n        if platform_user_handle:\n            basis_text += f\" ({platform_user_handle}) \"\n        if self.config_dict.get('gen_ai_support', None):\n            summarized_blog_post = self.summarize_text(entry)\n            if summarized_blog_post:\n                basis_text.text('\\n\\n\ud83d\udcd6 ')\n                basis_text.text(summarized_blog_post)\n        basis_text += f\"\\n\\n\ud83d\udd17 {entry.get('link', '')}\\n\\n{tags}\"\n\n        self.logger.info('*****************************')\n        self.logger.info(basis_text)\n        self.logger.info('*****************************')\n\n        return basis_text\n\n    @staticmethod\n    def generate_text_to_summarize(entry):\n        \"\"\"\n        Generate text to summarize.\n        \"\"\"\n        text = (\n            f\"Title: {entry.get('title', '')}\\n\"\n            f\"Summary: {entry.get('summary', '')}\"\n        )\n        if len(text.split()) &gt; 700:\n            words = text.split()[:700]\n            return ' '.join(words)\n        return text\n\n    @staticmethod\n    def clean_response(response):\n        \"\"\"\n        Clean response.\n        \"\"\"\n        return ' '.join(response.text.replace('\\n', ' ').split())\n\n    def summarize_text(self, entry):\n        \"\"\"\n        Summarize text using LLMs.\n        \"\"\"\n        text = self.generate_text_to_summarize(entry)\n        model = genai.GenerativeModel(\n            self.config_dict.get('gemini_model_name', '')\n        )\n        prompt_parts = [\n            'Summarize the content of the post in maximum 60 characters.',\n            'Be as concise as possible and be engaging.',\n            'Don\\'t repeat the title.',\n            text\n        ]\n        response = model.generate_content(prompt_parts)\n        response_cleaned = self.clean_response(response)\n        safety_ratings = response.candidates[0].safety_ratings\n        if all(\n            rating.probability.name == 'NEGLIGIBLE'\n            for rating in safety_ratings\n        ):\n            return response_cleaned\n        return ''\n\n    @staticmethod\n    def check_platform_handle(platform_user_handle):\n        \"\"\"\n        Check platform handle.\n        \"\"\"\n        if (len(platform_user_handle) &gt; 1\n                and not platform_user_handle.startswith('@')):\n            return f\"@{platform_user_handle}\"\n        return platform_user_handle\n\n    def build_post_bluesky(\n        self,\n        basis_text,\n        platform_user_handle,\n        tags,\n        entry\n    ):\n        \"\"\"\n        Build post for Bluesky.\n        \"\"\"\n        text_builder = client_utils.TextBuilder()\n        text_builder.text(basis_text)\n\n        platform_user_handle = self.check_platform_handle(platform_user_handle)\n\n        if platform_user_handle:\n            did = self.get_bluesky_did(platform_user_handle)\n            text_builder.mention(f\" ({platform_user_handle})\", did)\n        if self.config_dict.get('gen_ai_support', None):\n            summarized_blog_post = self.summarize_text(entry)\n            if summarized_blog_post:\n                text_builder.text('\\n\\n\ud83d\udcd6 ')\n                text_builder.text(summarized_blog_post)\n        text_builder.text('\\n\\n\ud83d\udd17 ')\n        link = entry.get('link', '')\n        text_builder.link(link, link)\n        text_builder.text('\\n\\n')\n        for tag in tags.split('#'):\n            tag_clean = tag.strip()\n            if tag_clean:\n                text_builder.tag(f\"#{tag_clean} \", tag_clean)\n        return text_builder\n\n    def build_post(self, entry, feed):\n        \"\"\"Take the entry dict and build a post\"\"\"\n\n        tags = self.define_tags(entry)\n        platform = self.config_dict.get('platform', '')\n        platform_user_handle = feed.get(platform)\n\n        title = entry.get('title', '')\n        name = feed.get('name', '')\n\n        basis_text = \"\"\n\n        if title:\n            basis_text += f\"\ud83d\udcdd '{title}'\\n\\n\"\n\n        if name:\n            basis_text += f\"\ud83d\udc64 {name}\"\n\n        if self.config_dict.get('platform', '') == 'mastodon':\n            return self.build_post_mastodon(\n                basis_text,\n                platform_user_handle,\n                tags,\n                entry\n            )\n        elif self.config_dict.get('platform', '') == 'bluesky':\n            return self.build_post_bluesky(\n                basis_text,\n                platform_user_handle,\n                tags,\n                entry\n            )\n\n    def send_post_to_mastodon(self, en, client, post_txt):\n        \"\"\"\n        Send post to Mastodon.\n        \"\"\"\n        media_content = en.get('media_content', None)\n        alt_text = en.get('alt_text', None)\n\n        if media_content:\n            try:\n                self.logger.info('Uploading media to mastodon')\n                filename = self.download_image(media_content)\n                media_upload_mastodon = client.media_post(filename)\n\n                if alt_text:\n                    self.logger.info('Adding description')\n                    client.media_update(media_upload_mastodon,\n                                        description=alt_text)\n\n                self.logger.info('Now ready to post... \u23f3')\n                client.status_post(post_txt, media_ids=media_upload_mastodon)\n\n                self.logger.info('Posted \ud83c\udf89')\n                return 'success'\n            except Exception as e:\n                self.logger.exception(\n                    'Urg, media could not be printed for %s. Exception: %s',\n                    en.get('link', 'unknown link'),\n                    e)\n                client.status_post(post_txt)\n                self.logger.info('Posted post without image.')\n                return 'failed'\n        else:\n            try:\n                client.status_post(post_txt)\n                self.logger.info('Posted \ud83c\udf89')\n                return 'success'\n            except Exception as e:\n                self.logger.exception(\n                    'Urg, exception %s for %s',\n                    e,\n                    en.get('link', 'unknown link')\n                )\n                return 'failed'\n\n    def send_post_to_bluesky(self, en, client, post_txt, embed_external):\n        \"\"\"\n        Send post to Bluesky.\n        \"\"\"\n        try:\n            if embed_external:\n                client.send_post(text=post_txt, embed=embed_external)\n            else:\n                client.send_post(text=post_txt)\n            self.logger.info(\"Posted \ud83c\udf89\")\n            return 'success'\n        except Exception as e:\n            self.logger.exception(\"Urg, exception %s for %s\", e, en['link'])\n            return 'failed'\n\n    def build_embed_external(self, en, client):\n        \"\"\"\n        Build embed external. This is a speciality of Bluesky's protocol.\n        \"\"\"\n        if en['media_content']:\n            filename = self.download_image(en['media_content'])\n            with open(filename, 'rb') as f:\n                img_data = f.read()\n\n            thumb = client.upload_blob(img_data)\n\n            return models.AppBskyEmbedExternal.Main(\n                external=models.AppBskyEmbedExternal.External(\n                    title=en['title'],\n                    description=en['title'],\n                    uri=en['link'],\n                    thumb=thumb.blob,\n                )\n            )\n        return None\n\n    def send_post(self, en, feed, client):\n        \"\"\"Turn the dict into post text and send the post\"\"\"\n        result = None\n        self.logger.info(\n            \"Preparing the post on %s \"\n            \"(%s) ...\",\n            self.config_dict['client_name'],\n            {self.config_dict['platform']}\n        )\n\n        post_txt = self.build_post(\n            en,\n            feed\n        )\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            result = self.send_post_to_mastodon(\n                en,\n                client,\n                post_txt\n            )\n        elif self.config_dict[\"platform\"] == \"bluesky\":\n            embed_external = self.build_embed_external(\n                en,\n                client\n            )\n            result = self.send_post_to_bluesky(\n                en,\n                client,\n                post_txt,\n                embed_external\n            )\n        return result\n\n    @staticmethod\n    def load_feed(feed_path, d):\n        \"\"\"Method to load RSS feed\"\"\"\n        full_fpd = feedparser.parse(feed_path)\n        return d + full_fpd.entries\n\n    @staticmethod\n    def get_rss_feed_archive(feed):\n        \"\"\"Method to get RSS feed archive content\"\"\"\n        archive_path = Path(feed['ARCHIVE'][0])\n        archive_file = archive_path / 'file.json'\n\n        if archive_path.exists():\n            try:\n                with archive_file.open('rb') as fp:\n                    rss_feed_archive = json.load(fp)\n            except (FileNotFoundError, json.JSONDecodeError):\n                rss_feed_archive = {'link': []}\n        else:\n            if any(\n                domain in feed['ARCHIVE'][0]\n                for domain in [\"www.youtube.com\", \"medium.com\"]\n            ):\n                archive_path = archive_path / \\\n                    feed['name'].lower().replace(' ', '-')\n\n            archive_path.mkdir(parents=True, exist_ok=True)\n            rss_feed_archive = {'link': []}\n\n        return rss_feed_archive\n\n    @staticmethod\n    def get_number_of_archive_entries(d, rss_feed_archive):\n        \"\"\"\n        Calculate the number of entries in the feed and archive,\n        ensuring archive structure is correct.\n        \"\"\"\n        number_of_entries_feed = len(d)\n\n        if 'link' in rss_feed_archive and isinstance(\n            rss_feed_archive['link'],\n            list\n        ):\n            number_of_entries_archive = len(set(rss_feed_archive['link']))\n        else:\n            # Fix the archive structure if 'link' key is missing or incorrect\n            rss_feed_archive = {'link': list(set(rss_feed_archive))}\n            number_of_entries_archive = len(rss_feed_archive['link'])\n\n        return (\n            rss_feed_archive,\n            number_of_entries_archive,\n            number_of_entries_feed,\n        )\n\n    @staticmethod\n    def adjust_archive_path(base_path, domain, counter_name):\n        \"\"\"\n        Helper function to clean up path construction for\n        YouTube and Medium\n        \"\"\"\n        feed_name_slug = counter_name.lower().replace(' ', '-')\n        if \"www.youtube.com\" in domain or \"medium.com\" in domain:\n            return base_path / feed_name_slug / feed_name_slug\n        return base_path\n\n    def get_folder_path(self, feed):\n        \"\"\"Method to identify folder path\"\"\"\n\n        rss_feeds = feed.get('rss_feed', [])\n        archive_paths = []\n        archive = f\"archive/{self.config_dict.get('archive', '')}\"\n\n        if len(rss_feeds) &gt; 1:\n            for rss_feed in rss_feeds:\n                domain = urlsplit(rss_feed).netloc\n                folder_path = Path(archive) / domain\n                archive_paths.append(str(folder_path))\n\n        elif len(rss_feeds) == 1:\n            domain = urlsplit(rss_feeds[0]).netloc\n            folder_path = Path(archive) / domain\n            folder_path = self.adjust_archive_path(\n                folder_path,\n                domain,\n                feed['name']\n            )\n            archive_paths.append(str(folder_path))\n\n        feed['ARCHIVE'] = archive_paths\n        return feed\n\n    def process_feed(self, feed, count_post, client):\n        \"\"\"\n        Process the RSS feed and generate a post for any entry\n        we haven't yet seen.\n        \"\"\"\n        name = feed.get('name', 'unknown name')\n        rss_feed = feed.get('rss_feed', 'unknown feed')\n        self.logger.info(\"=========================================\")\n        self.logger.info(\n            'Begin processing of feeds from %s (%s)',\n            name,\n            rss_feed\n        )\n\n        feed = self.get_folder_path(feed)\n\n        d = []\n\n        for feed_path in rss_feed:\n            # if \"medium.com\" in feed_path:\n            #     parsed_url = urlparse(feed_path)\n            #     subdomain = parsed_url.hostname.split('.')[0]\n            #     feed_path = f\"https://medium.com/feed/@{subdomain}\"\n            # # Load the feed\n            try:\n                d = self.load_feed(feed_path, d)\n                rss_feed_archive = self.get_rss_feed_archive(feed)\n                # Identify number of entries\n                (\n                    rss_feed_archive,\n                    number_of_entries_archive,\n                    number_of_entries_feed\n                ) = self.get_number_of_archive_entries(d, rss_feed_archive)\n                # If there are more entries, go through the list:\n\n                feed_config = {\n                    'rss_feed_archive': rss_feed_archive,\n                    'number_of_entries_feed': number_of_entries_feed,\n                    'feed': feed,\n                    'd': d\n                }\n\n                if number_of_entries_feed &gt; number_of_entries_archive:\n                    count_post = self._process_feed(\n                        client,\n                        count_post,\n                        feed_config\n                    )\n                    self.logger.info(\n                        'New RSS feeds are successfully loaded and '\n                        'processed.'\n                    )\n                    return count_post\n                self.logger.info('Maximum number of posts is already posted.')\n                return count_post\n            except Exception as e:\n                self.logger.info(\n                    '\ud83d\udea8 Feed for %s not available because %s',\n                    feed_path,\n                    e\n                )\n                return count_post\n\n    def _save_rss_feed_archive(self, feed, rss_feed_archive):\n        \"\"\" Save RSS feed archive to a file \"\"\"\n        archive_path = os.path.join(feed['ARCHIVE'][0], 'file.json')\n        with open(archive_path, 'wb') as fp:\n            json.dump(rss_feed_archive, fp)\n        self.logger.info(\"Archive for %s updated successfully.\", feed['name'])\n\n    @staticmethod\n    def _get_media_content(entry):\n        \"\"\" Extract media content from an RSS entry \"\"\"\n        en = {}\n        if 'www.youtube.com' in entry.link:\n            en['media_content'] = (\n                f\"http://img.youtube.com/vi/\"\n                f\"{entry.id.replace('yt:video:', '')}/hqdefault.jpg\"\n            )\n        elif 'media_content' in entry:\n            en['media_content'] = entry.media_content[0]['url']\n        else:\n            soup = BeautifulSoup(entry.summary, \"html.parser\")\n            img_url = [\n                img['src']\n                for img in soup.find_all('img')\n                if img.has_attr('src')\n            ]\n            alt_text = [\n                img['alt']\n                for img in soup.find_all('img')\n                if img.has_attr('alt')\n            ]\n            if img_url:\n                en['media_content'] = img_url[0]\n            if alt_text:\n                en['alt_text'] = alt_text[0] if alt_text else ''\n        return en\n\n    def _process_feed(\n        self,\n        client,\n        count_post,\n        feed_config\n    ):\n        \"\"\" Process RSS feed entries and send posts \"\"\"\n        count = 0\n        count_fails = 0\n        result = None\n        for _, entry in enumerate(feed_config['d']):\n            if count &gt;= 1:  # Limit to 1 post per run\n                break\n            elif count_fails &gt;= 1:\n                break\n\n            en = {\n                'title': entry.title,\n                'link': entry.link,\n                'pub_date': entry.published,\n                'tags': [tag['term'] for tag in getattr(entry, 'tags', [])],\n                'media_content': [],\n                'summary': entry.summary\n            }\n\n            if not en['tags'] and 'category' in entry:\n                en['tags'].append(entry.category)\n\n            if self.process_images:\n                en.update(self._get_media_content(entry))\n\n            if en['link'] not in feed_config['rss_feed_archive']['link']:\n                feed_config['rss_feed_archive']['link'].append(en['link'])\n                if self.no_dry_run:\n                    result = self.send_post(en, feed_config['feed'], client)\n                if result == 'success':\n                    count_post += 1\n                    count += 1\n                    time.sleep(1)\n                elif result == 'failed':\n                    count_fails += 1\n                    time.sleep(1)\n\n        if self.no_dry_run:\n            if result == 'success':\n                self._save_rss_feed_archive(\n                    feed_config['feed'],\n                    feed_config['rss_feed_archive']\n                )\n\n        return count_post\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.adjust_archive_path","title":"<code>adjust_archive_path(base_path, domain, counter_name)</code>  <code>staticmethod</code>","text":"<p>Helper function to clean up path construction for YouTube and Medium</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef adjust_archive_path(base_path, domain, counter_name):\n    \"\"\"\n    Helper function to clean up path construction for\n    YouTube and Medium\n    \"\"\"\n    feed_name_slug = counter_name.lower().replace(' ', '-')\n    if \"www.youtube.com\" in domain or \"medium.com\" in domain:\n        return base_path / feed_name_slug / feed_name_slug\n    return base_path\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.build_embed_external","title":"<code>build_embed_external(en, client)</code>","text":"<p>Build embed external. This is a speciality of Bluesky's protocol.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def build_embed_external(self, en, client):\n    \"\"\"\n    Build embed external. This is a speciality of Bluesky's protocol.\n    \"\"\"\n    if en['media_content']:\n        filename = self.download_image(en['media_content'])\n        with open(filename, 'rb') as f:\n            img_data = f.read()\n\n        thumb = client.upload_blob(img_data)\n\n        return models.AppBskyEmbedExternal.Main(\n            external=models.AppBskyEmbedExternal.External(\n                title=en['title'],\n                description=en['title'],\n                uri=en['link'],\n                thumb=thumb.blob,\n            )\n        )\n    return None\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.build_post","title":"<code>build_post(entry, feed)</code>","text":"<p>Take the entry dict and build a post</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def build_post(self, entry, feed):\n    \"\"\"Take the entry dict and build a post\"\"\"\n\n    tags = self.define_tags(entry)\n    platform = self.config_dict.get('platform', '')\n    platform_user_handle = feed.get(platform)\n\n    title = entry.get('title', '')\n    name = feed.get('name', '')\n\n    basis_text = \"\"\n\n    if title:\n        basis_text += f\"\ud83d\udcdd '{title}'\\n\\n\"\n\n    if name:\n        basis_text += f\"\ud83d\udc64 {name}\"\n\n    if self.config_dict.get('platform', '') == 'mastodon':\n        return self.build_post_mastodon(\n            basis_text,\n            platform_user_handle,\n            tags,\n            entry\n        )\n    elif self.config_dict.get('platform', '') == 'bluesky':\n        return self.build_post_bluesky(\n            basis_text,\n            platform_user_handle,\n            tags,\n            entry\n        )\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.build_post_bluesky","title":"<code>build_post_bluesky(basis_text, platform_user_handle, tags, entry)</code>","text":"<p>Build post for Bluesky.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def build_post_bluesky(\n    self,\n    basis_text,\n    platform_user_handle,\n    tags,\n    entry\n):\n    \"\"\"\n    Build post for Bluesky.\n    \"\"\"\n    text_builder = client_utils.TextBuilder()\n    text_builder.text(basis_text)\n\n    platform_user_handle = self.check_platform_handle(platform_user_handle)\n\n    if platform_user_handle:\n        did = self.get_bluesky_did(platform_user_handle)\n        text_builder.mention(f\" ({platform_user_handle})\", did)\n    if self.config_dict.get('gen_ai_support', None):\n        summarized_blog_post = self.summarize_text(entry)\n        if summarized_blog_post:\n            text_builder.text('\\n\\n\ud83d\udcd6 ')\n            text_builder.text(summarized_blog_post)\n    text_builder.text('\\n\\n\ud83d\udd17 ')\n    link = entry.get('link', '')\n    text_builder.link(link, link)\n    text_builder.text('\\n\\n')\n    for tag in tags.split('#'):\n        tag_clean = tag.strip()\n        if tag_clean:\n            text_builder.tag(f\"#{tag_clean} \", tag_clean)\n    return text_builder\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.build_post_mastodon","title":"<code>build_post_mastodon(basis_text, platform_user_handle, tags, entry)</code>","text":"<p>Build Mastodon post.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def build_post_mastodon(\n    self, basis_text, platform_user_handle, tags, entry\n):\n    \"\"\"\n    Build Mastodon post.\n    \"\"\"\n    platform_user_handle = self.check_platform_handle(platform_user_handle)\n\n    if platform_user_handle:\n        basis_text += f\" ({platform_user_handle}) \"\n    if self.config_dict.get('gen_ai_support', None):\n        summarized_blog_post = self.summarize_text(entry)\n        if summarized_blog_post:\n            basis_text.text('\\n\\n\ud83d\udcd6 ')\n            basis_text.text(summarized_blog_post)\n    basis_text += f\"\\n\\n\ud83d\udd17 {entry.get('link', '')}\\n\\n{tags}\"\n\n    self.logger.info('*****************************')\n    self.logger.info(basis_text)\n    self.logger.info('*****************************')\n\n    return basis_text\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.check_platform_handle","title":"<code>check_platform_handle(platform_user_handle)</code>  <code>staticmethod</code>","text":"<p>Check platform handle.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef check_platform_handle(platform_user_handle):\n    \"\"\"\n    Check platform handle.\n    \"\"\"\n    if (len(platform_user_handle) &gt; 1\n            and not platform_user_handle.startswith('@')):\n        return f\"@{platform_user_handle}\"\n    return platform_user_handle\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.clean_response","title":"<code>clean_response(response)</code>  <code>staticmethod</code>","text":"<p>Clean response.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef clean_response(response):\n    \"\"\"\n    Clean response.\n    \"\"\"\n    return ' '.join(response.text.replace('\\n', ' ').split())\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.define_tags","title":"<code>define_tags(entry)</code>","text":"<p>Define tags that will be posted along the posts.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def define_tags(self, entry):\n    \"\"\"\n    Define tags that will be posted along the posts.\n    \"\"\"\n    if self.config_dict.get('client_name', '') == 'pyladies_bot':\n        tags = '#pyladies #python '\n    elif self.config_dict.get('client_name', '') == 'rladies_bot':\n        tags = '#rladies #rstats '\n    else:\n        self.logger.info('Bot name not found')\n        tags = ''\n\n    pub_date = self.parse_pub_date(entry)\n\n    age_of_post = datetime.now() - pub_date\n\n    if age_of_post.days &gt; 730:\n        tags += '#oldiebutgoodie '\n\n    if len(entry['tags']) &gt; 0:\n        for tag in entry['tags']:\n            if tag.lower() in ['pyladies', 'python', 'rstats', 'rladies']:\n                pass\n            else:\n                tags += (\n                    f\"#{tag.replace(' ', '').replace('-', '').lower()} \"\n                )\n\n    return tags\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.download_image","title":"<code>download_image(url)</code>","text":"<p>Downloads an image from the given URL and saves it locally, organizing files by domain name.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def download_image(self, url: str):\n    \"\"\"\n    Downloads an image from the given URL and saves it locally,\n    organizing files by domain name.\n    \"\"\"\n    try:\n        filename = ''\n        # Parse the URL components\n        if self.config_dict[\"platform\"] == \"bluesky\":\n            domain = urlsplit(url).path\n            filename = posixpath.basename(domain)\n        elif self.config_dict[\"platform\"] == \"mastodon\":\n            domain = urlsplit(url).netloc\n            filename = posixpath.basename(urlsplit(url).path)\n\n        # Create folder structure based on the domain name\n        domain_dir = Path(self.config_dict['images']) / domain\n        domain_dir.mkdir(parents=True, exist_ok=True)\n\n        # Full file path for the image\n        file_path = domain_dir / filename\n\n        if file_path.is_file():\n            self.logger.info(\"Image already downloaded: %s\", file_path)\n            return str(file_path)\n\n        # Set user-agent headers for the request\n        headers = {\n            'User-Agent': (\n                'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) '\n                'Gecko/20100101 Firefox/20.0'\n            )\n        }\n\n        # Download the image\n        self.logger.info(\"Downloading image from %s...\", url)\n        response = requests.get(\n            url,\n            headers=headers,\n            stream=True,\n            timeout=15\n        )\n        response.raise_for_status()  # Raises an exception for HTTP errors\n\n        # Save the image to the designated path\n        with open(file_path, 'wb') as out_file:\n            shutil.copyfileobj(response.raw, out_file)\n\n        self.logger.info(\"Image successfully downloaded: %s\", file_path)\n        return str(file_path)\n\n    except requests.exceptions.RequestException as e:\n        self.logger.error(\"Failed to download image from %s: %e\", url, e)\n        return None\n    except OSError as e:\n        self.logger.error(\"File system error while saving image: %s\", e)\n        return None\n    finally:\n        if 'response' in locals():\n            response.close()\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.generate_text_to_summarize","title":"<code>generate_text_to_summarize(entry)</code>  <code>staticmethod</code>","text":"<p>Generate text to summarize.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef generate_text_to_summarize(entry):\n    \"\"\"\n    Generate text to summarize.\n    \"\"\"\n    text = (\n        f\"Title: {entry.get('title', '')}\\n\"\n        f\"Summary: {entry.get('summary', '')}\"\n    )\n    if len(text.split()) &gt; 700:\n        words = text.split()[:700]\n        return ' '.join(words)\n    return text\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.get_bluesky_did","title":"<code>get_bluesky_did(platform_user_handle)</code>","text":"<p>Method to get Bluesky DID to uniquely identify (and tag) user.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def get_bluesky_did(self, platform_user_handle):\n    \"\"\"\n    Method to get Bluesky DID to uniquely identify (and tag) user.\n    \"\"\"\n    url = (\n        f\"https://bsky.social/xrpc/com.atproto.identity.resolveHandle?\"\n        f\"handle={platform_user_handle.lstrip('@')}\"\n    )\n    try:\n        response = requests.get(url)\n\n        if response.status_code == 200:\n            data = response.json()\n            did = data.get('did', None)\n\n            if did:\n                return did\n            else:\n                self.logger.info(\n                    'The \"did\" field was not found in the response.'\n                )\n        else:\n            self.logger.info(\n                'Failed to retrieve data. Status code: %s',\n                response.status_code\n            )\n\n    except requests.RequestException as e:\n        self.logger.info('An error occurred: %s', e)\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.get_config","title":"<code>get_config()</code>","text":"<p>Get config file</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def get_config(self):\n    \"\"\"\n    Get config file\n    \"\"\"\n    if (self.config_dict is None) and (self.no_dry_run):\n        self.config_dict = {\n            \"platform\": os.getenv(\"PLATFORM\"),\n            \"archive\": os.getenv(\"ARCHIVE_DIRECTORY\"),\n            \"images\": os.getenv(\"IMAGES\"),\n            \"counter\": self._ensure_metadata_prefix(\n                os.getenv(\"COUNTER\", \"\")\n            ),\n            \"password\": os.getenv(\"PASSWORD\"),\n            \"username\": os.getenv(\"USERNAME\"),\n            \"client_name\": os.getenv(\"CLIENT_NAME\"),\n            \"json_file\": self._ensure_metadata_prefix(\n                os.getenv(\"JSON_FILE\", \"\")\n            ),\n            \"gen_ai_support\": True,\n            \"gemini_api_key\": os.getenv(\"GEMINI_API_KEY\"),\n            \"gemini_model_name\": \"gemini-2.5-flash\"\n        }\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            self.config_dict[\"api_base_url\"] = config.API_BASE_URL\n            self.config_dict[\"mastodon_visibility\"] = (\n                config.MASTODON_VISIBILITY\n            )\n            self.config_dict[\"client_id\"] = os.getenv(\"CLIENT_ID\")\n            self.config_dict[\"client_secret\"] = os.getenv(\"CLIENT_SECRET\")\n            self.config_dict[\"access_token\"] = os.getenv(\"ACCESS_TOKEN\")\n            self.config_dict[\"client_cred_file\"] = os.getenv(\n                'BOT_CLIENTCRED_SECRET'\n            )\n        else:\n            self.config_dict[\"api_base_url\"] = \"bluesky\"\n\n        if self.config_dict[\"gen_ai_support\"]:\n            genai.configure(api_key=self.config_dict[\"gemini_api_key\"])\n    else:\n        self.config_dict['json_file'] = self._ensure_metadata_prefix(\n            self.config_dict.get('json_file')\n        )\n        self.config_dict['counter'] = self._ensure_metadata_prefix(\n            self.config_dict.get('counter')\n        )\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.get_folder_path","title":"<code>get_folder_path(feed)</code>","text":"<p>Method to identify folder path</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def get_folder_path(self, feed):\n    \"\"\"Method to identify folder path\"\"\"\n\n    rss_feeds = feed.get('rss_feed', [])\n    archive_paths = []\n    archive = f\"archive/{self.config_dict.get('archive', '')}\"\n\n    if len(rss_feeds) &gt; 1:\n        for rss_feed in rss_feeds:\n            domain = urlsplit(rss_feed).netloc\n            folder_path = Path(archive) / domain\n            archive_paths.append(str(folder_path))\n\n    elif len(rss_feeds) == 1:\n        domain = urlsplit(rss_feeds[0]).netloc\n        folder_path = Path(archive) / domain\n        folder_path = self.adjust_archive_path(\n            folder_path,\n            domain,\n            feed['name']\n        )\n        archive_paths.append(str(folder_path))\n\n    feed['ARCHIVE'] = archive_paths\n    return feed\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.get_number_of_archive_entries","title":"<code>get_number_of_archive_entries(d, rss_feed_archive)</code>  <code>staticmethod</code>","text":"<p>Calculate the number of entries in the feed and archive, ensuring archive structure is correct.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef get_number_of_archive_entries(d, rss_feed_archive):\n    \"\"\"\n    Calculate the number of entries in the feed and archive,\n    ensuring archive structure is correct.\n    \"\"\"\n    number_of_entries_feed = len(d)\n\n    if 'link' in rss_feed_archive and isinstance(\n        rss_feed_archive['link'],\n        list\n    ):\n        number_of_entries_archive = len(set(rss_feed_archive['link']))\n    else:\n        # Fix the archive structure if 'link' key is missing or incorrect\n        rss_feed_archive = {'link': list(set(rss_feed_archive))}\n        number_of_entries_archive = len(rss_feed_archive['link'])\n\n    return (\n        rss_feed_archive,\n        number_of_entries_archive,\n        number_of_entries_feed,\n    )\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.get_rss_feed_archive","title":"<code>get_rss_feed_archive(feed)</code>  <code>staticmethod</code>","text":"<p>Method to get RSS feed archive content</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef get_rss_feed_archive(feed):\n    \"\"\"Method to get RSS feed archive content\"\"\"\n    archive_path = Path(feed['ARCHIVE'][0])\n    archive_file = archive_path / 'file.json'\n\n    if archive_path.exists():\n        try:\n            with archive_file.open('rb') as fp:\n                rss_feed_archive = json.load(fp)\n        except (FileNotFoundError, json.JSONDecodeError):\n            rss_feed_archive = {'link': []}\n    else:\n        if any(\n            domain in feed['ARCHIVE'][0]\n            for domain in [\"www.youtube.com\", \"medium.com\"]\n        ):\n            archive_path = archive_path / \\\n                feed['name'].lower().replace(' ', '-')\n\n        archive_path.mkdir(parents=True, exist_ok=True)\n        rss_feed_archive = {'link': []}\n\n    return rss_feed_archive\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.load_feed","title":"<code>load_feed(feed_path, d)</code>  <code>staticmethod</code>","text":"<p>Method to load RSS feed</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>@staticmethod\ndef load_feed(feed_path, d):\n    \"\"\"Method to load RSS feed\"\"\"\n    full_fpd = feedparser.parse(feed_path)\n    return d + full_fpd.entries\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.parse_pub_date","title":"<code>parse_pub_date(entry)</code>","text":"<p>Method to parse the publication date</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def parse_pub_date(self, entry):\n    \"\"\"Method to parse the publication date\"\"\"\n    date_formats = [\n        \"%a, %d %b %Y %H:%M:%S %z\",  # Format 1\n        \"%a, %d %b %Y %H:%M:%S %Z\",  # Format 2\n        \"%Y-%m-%d\",                  # Format 3\n        \"%Y-%m-%dT%H:%M:%S.%f%Z\"     # Format 4\n    ]\n\n    pub_date_str = entry.get('pub_date', '')\n\n    for date_format in date_formats:\n        try:\n            pub_date = datetime.strptime(\n                pub_date_str, date_format).replace(tzinfo=None)\n            return pub_date  # Return as soon as a valid format is found\n        except ValueError:\n            self.logger.info(\n                \"Failed to parse date with format: %s\",\n                date_format\n            )\n\n    # If none of the formats match, use the current date as a fallback\n    self.logger.warning(\n        \"No matching date format found. Using current date.\"\n    )\n    return datetime.now()  # Fallback value\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.process_feed","title":"<code>process_feed(feed, count_post, client)</code>","text":"<p>Process the RSS feed and generate a post for any entry we haven't yet seen.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def process_feed(self, feed, count_post, client):\n    \"\"\"\n    Process the RSS feed and generate a post for any entry\n    we haven't yet seen.\n    \"\"\"\n    name = feed.get('name', 'unknown name')\n    rss_feed = feed.get('rss_feed', 'unknown feed')\n    self.logger.info(\"=========================================\")\n    self.logger.info(\n        'Begin processing of feeds from %s (%s)',\n        name,\n        rss_feed\n    )\n\n    feed = self.get_folder_path(feed)\n\n    d = []\n\n    for feed_path in rss_feed:\n        # if \"medium.com\" in feed_path:\n        #     parsed_url = urlparse(feed_path)\n        #     subdomain = parsed_url.hostname.split('.')[0]\n        #     feed_path = f\"https://medium.com/feed/@{subdomain}\"\n        # # Load the feed\n        try:\n            d = self.load_feed(feed_path, d)\n            rss_feed_archive = self.get_rss_feed_archive(feed)\n            # Identify number of entries\n            (\n                rss_feed_archive,\n                number_of_entries_archive,\n                number_of_entries_feed\n            ) = self.get_number_of_archive_entries(d, rss_feed_archive)\n            # If there are more entries, go through the list:\n\n            feed_config = {\n                'rss_feed_archive': rss_feed_archive,\n                'number_of_entries_feed': number_of_entries_feed,\n                'feed': feed,\n                'd': d\n            }\n\n            if number_of_entries_feed &gt; number_of_entries_archive:\n                count_post = self._process_feed(\n                    client,\n                    count_post,\n                    feed_config\n                )\n                self.logger.info(\n                    'New RSS feeds are successfully loaded and '\n                    'processed.'\n                )\n                return count_post\n            self.logger.info('Maximum number of posts is already posted.')\n            return count_post\n        except Exception as e:\n            self.logger.info(\n                '\ud83d\udea8 Feed for %s not available because %s',\n                feed_path,\n                e\n            )\n            return count_post\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.process_feeds","title":"<code>process_feeds(feeds, counter_name, count_post, client)</code>","text":"<p>Method to handle processing of all feeds.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def process_feeds(self, feeds, counter_name, count_post, client):\n    \"\"\"\n    Method to handle processing of all feeds.\n    \"\"\"\n    for feed in feeds:\n        if counter_name not in (feed['name'], '\\n', ''):\n            continue\n        if len(feed['rss_feed']) == 0 or feed['rss_feed'] == [None]:\n            continue\n\n        is_last_feed = feed['name'] == feeds[-1]['name']\n\n        if count_post == 0 and is_last_feed:\n            count_post = self.process_feed(\n                feed,\n                count_post,\n                client\n            )\n\n            # Add the counter_name\n            if is_last_feed:\n                new_feed = feeds[0]\n                count_post = self.process_feed(\n                    new_feed,\n                    count_post,\n                    client\n                )\n\n                self.logger.info(\n                    \"Successfully promoted blog posts. \"\n                    \"Thank you and see you next time!\")\n                self.update_counter(feeds[1]['name'])\n                break\n\n        elif count_post &lt; 2:\n            count_post = self.process_feed(\n                feed,\n                count_post,\n                client\n            )\n            counter_name = ''\n            if is_last_feed:\n                self.update_counter(feed['name'])\n            self.logger.info(\n                \"=========================================\")\n\n        else:\n            self.logger.info(\n                \"Successfully promoted blog posts. \"\n                \"Thank you and see you next time!\")\n            self.update_counter(feed['name'])\n            break\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.promote_blog_post","title":"<code>promote_blog_post()</code>","text":"<p>Core method to promote blog post</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def promote_blog_post(self):\n    \"\"\"Core method to promote blog post\"\"\"\n\n    self.get_config()\n\n    if self.no_dry_run:\n        client_name = self.config_dict.get('client_name', 'unknown')\n        self.logger.info(\"\")\n        self.logger.info(\n            'Initializing %s Bot',\n            client_name\n        )\n        separator = \"%s\", \"=\" * (len(client_name) + 17)\n        self.logger.info(separator)\n        self.logger.info(\n            \" &gt; Connecting to %s\",\n            self.config_dict.get('api_base_url', '')\n        )\n\n        if self.config_dict[\"platform\"] == \"mastodon\":\n            _, client = login_mastodon(self.config_dict)\n        elif self.config_dict[\"platform\"] == \"bluesky\":\n            client = login_bluesky(self.config_dict)\n    else:\n        client = None\n\n    feeds = self.read_metadata_json()\n    counter_name = self.read_counter_name()\n\n    # Initiate count to post a maximum of 2 posts per run\n    count_post = 0\n\n    # Drop empty rss_feeds\n    feeds = [x for x in feeds if x['rss_feed'] != '']\n\n    if self.no_dry_run:\n        self.process_feeds(feeds, counter_name, count_post, client)\n    else:\n        for feed in feeds:\n            count_post = self.process_feed(\n                feed,\n                count_post,\n                client\n            )\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.read_counter_name","title":"<code>read_counter_name()</code>","text":"<p>Read counter name from txt file</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def read_counter_name(self):\n    \"\"\"\n    Read counter name from txt file\n    \"\"\"\n    with open(self.config_dict[\"counter\"], 'r', encoding='utf-8') as f:\n        return f.read()\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.read_metadata_json","title":"<code>read_metadata_json()</code>","text":"<p>Read metadata JSON file</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def read_metadata_json(self):\n    \"\"\"\n    Read metadata JSON file\n    \"\"\"\n    with open(self.config_dict[\"json_file\"], 'rb') as fp:\n        self.logger.info(\n            \"=============================================\"\n        )\n        feeds = json.load(fp)\n        self.logger.info('Meta data was successfully loaded')\n        self.logger.info(\n            \"=============================================\"\n        )\n        return feeds\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.send_post","title":"<code>send_post(en, feed, client)</code>","text":"<p>Turn the dict into post text and send the post</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def send_post(self, en, feed, client):\n    \"\"\"Turn the dict into post text and send the post\"\"\"\n    result = None\n    self.logger.info(\n        \"Preparing the post on %s \"\n        \"(%s) ...\",\n        self.config_dict['client_name'],\n        {self.config_dict['platform']}\n    )\n\n    post_txt = self.build_post(\n        en,\n        feed\n    )\n    if self.config_dict[\"platform\"] == \"mastodon\":\n        result = self.send_post_to_mastodon(\n            en,\n            client,\n            post_txt\n        )\n    elif self.config_dict[\"platform\"] == \"bluesky\":\n        embed_external = self.build_embed_external(\n            en,\n            client\n        )\n        result = self.send_post_to_bluesky(\n            en,\n            client,\n            post_txt,\n            embed_external\n        )\n    return result\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.send_post_to_bluesky","title":"<code>send_post_to_bluesky(en, client, post_txt, embed_external)</code>","text":"<p>Send post to Bluesky.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def send_post_to_bluesky(self, en, client, post_txt, embed_external):\n    \"\"\"\n    Send post to Bluesky.\n    \"\"\"\n    try:\n        if embed_external:\n            client.send_post(text=post_txt, embed=embed_external)\n        else:\n            client.send_post(text=post_txt)\n        self.logger.info(\"Posted \ud83c\udf89\")\n        return 'success'\n    except Exception as e:\n        self.logger.exception(\"Urg, exception %s for %s\", e, en['link'])\n        return 'failed'\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.send_post_to_mastodon","title":"<code>send_post_to_mastodon(en, client, post_txt)</code>","text":"<p>Send post to Mastodon.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def send_post_to_mastodon(self, en, client, post_txt):\n    \"\"\"\n    Send post to Mastodon.\n    \"\"\"\n    media_content = en.get('media_content', None)\n    alt_text = en.get('alt_text', None)\n\n    if media_content:\n        try:\n            self.logger.info('Uploading media to mastodon')\n            filename = self.download_image(media_content)\n            media_upload_mastodon = client.media_post(filename)\n\n            if alt_text:\n                self.logger.info('Adding description')\n                client.media_update(media_upload_mastodon,\n                                    description=alt_text)\n\n            self.logger.info('Now ready to post... \u23f3')\n            client.status_post(post_txt, media_ids=media_upload_mastodon)\n\n            self.logger.info('Posted \ud83c\udf89')\n            return 'success'\n        except Exception as e:\n            self.logger.exception(\n                'Urg, media could not be printed for %s. Exception: %s',\n                en.get('link', 'unknown link'),\n                e)\n            client.status_post(post_txt)\n            self.logger.info('Posted post without image.')\n            return 'failed'\n    else:\n        try:\n            client.status_post(post_txt)\n            self.logger.info('Posted \ud83c\udf89')\n            return 'success'\n        except Exception as e:\n            self.logger.exception(\n                'Urg, exception %s for %s',\n                e,\n                en.get('link', 'unknown link')\n            )\n            return 'failed'\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.summarize_text","title":"<code>summarize_text(entry)</code>","text":"<p>Summarize text using LLMs.</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def summarize_text(self, entry):\n    \"\"\"\n    Summarize text using LLMs.\n    \"\"\"\n    text = self.generate_text_to_summarize(entry)\n    model = genai.GenerativeModel(\n        self.config_dict.get('gemini_model_name', '')\n    )\n    prompt_parts = [\n        'Summarize the content of the post in maximum 60 characters.',\n        'Be as concise as possible and be engaging.',\n        'Don\\'t repeat the title.',\n        text\n    ]\n    response = model.generate_content(prompt_parts)\n    response_cleaned = self.clean_response(response)\n    safety_ratings = response.candidates[0].safety_ratings\n    if all(\n        rating.probability.name == 'NEGLIGIBLE'\n        for rating in safety_ratings\n    ):\n        return response_cleaned\n    return ''\n</code></pre>"},{"location":"reference/#src.promote_blog_post.PromoteBlogPost.update_counter","title":"<code>update_counter(counter_name)</code>","text":"<p>Update counter name</p> Source code in <code>src/promote_blog_post.py</code> <pre><code>def update_counter(self, counter_name):\n    \"\"\"\n    Update counter name\n    \"\"\"\n    with open(\n        self.config_dict[\"counter\"],\n        'w',\n        encoding='utf-8'\n    ) as txt_file:\n        txt_file.write(counter_name)\n</code></pre>"}]}